metavar termvar, x, y ::=
  {{ tex \mathit{[[termvar]]} }} {{ com term variable }}
metavar heapvar, h, init, mem ::=
  {{ tex \mathit{[[heapvar]]} }} {{ com heap variable }}


grammar
  A, B :: Ty ::=                                        {{ com Types }}
    | Unit                ::   :: Unit                    {{ com unit }}
    | Bool                ::   :: Bool                    {{ com booleans }}
    | Qbit                ::   :: Qubit                   {{ com qubits }}
    | U                   ::   :: Unitary                 {{ com unitary }}
    | A otimes B                  ::   :: pair                    {{ com product }}
    | Pi x : A . B                ::   :: Pi    (+ bind x in B +) {{ com dependent function }}
    | A -> B                      :: S :: arrow                   {{ com function }}
    | D . Psi . { P } x : A { Q } ::   :: Hoare (+ bind x in Q +) {{ com hoare type }}
    | { P } x : A { Q }   :: S :: HoareS
    | ( A )               :: S :: paren
    | [ M / x ] A         :: M :: tsub

  P, Q, R :: Ass ::= {{ com Assertions }}
    | top                 ::   :: Top
    | bot                 ::   :: Bot
    | P /\ Q              ::   :: And
    | P \/ Q              ::   :: Or
    | P * Q               ::   :: SepCon
    | P imp Q             ::   :: Imply
    | not P               ::   :: Not
    | ex x : A . P        ::   :: Exists  (+ bind x in P +)
    | all x : A . P       ::   :: Forall  (+ bind x in P +)
    | ex h : heap . P     ::   :: ExistsH (+ bind h in P +)
    | ex D . Psi . P      :: S :: CExistsH
    | all D . Psi . P     :: S :: CForallH
    | all h : heap . P    ::   :: ForallH (+ bind h in P +)
    | Id_A ( M , N )      ::   :: TermId {{ com propositional equality }}
    | HId ( H , G )       ::   :: HeapId {{ com propositional heap equality }}
    | indom ( H , M )     ::   :: InDomain
    | seleq ( H , M , N ) :: S :: SelEq
    | this ( H )          :: S :: This
    | P -o Q              :: S :: Difference
    | ( P )               :: S :: Paren

  H, G :: Heap ::= {{ com Quantum Heaps }}
    | h                   ::   :: HeapVar
    | empty               ::   :: Empty
    | upd ( H , M , N )   ::   :: Update
    | [ H / h ]           :: S :: hsub

  K, L :: ElimTm ::=                                    {{ com Elim Terms }}
    | x                   ::   :: Var                     {{ com variable }}
    | K M                 ::   :: App                     {{ com application }}
    | M : A               ::   :: Annot
    | ( K )               :: S :: paren
    | [ K / x ] M         :: M :: tsub

  M, N, O :: IntroTm ::=                                {{ com Intro Terms }}
    | K                   ::   :: Elim
    | \ x . M             ::   :: Lam  (+ bind x in M +)  {{ com abstraction }}
    | ()                  ::   :: unit
    | do E                ::   :: Computation
    | true                ::   :: True
    | false               ::   :: False

  c :: Cmd ::= {{ com Primitive Quantum Commands }}
    | mkQbit M           :: :: init
    | applyU M           :: :: apply
    | measQbit M         :: :: measure

  E, F :: Comp ::=  {{ com Computations }}
    | return M        ::   :: lift
    | x <- K ; E      ::   :: bindK     (+ bind x in E +)
    | x <= c ; E      ::   :: bindC     (+ bind x in E +)
    | x =_A M ; E     ::   :: bindPure  (+ bind x in E +)
    | ( E )           :: S :: paren
    | < E / x : A > F :: M :: msub                        {{ com monadic substitution }}

  D {{ tex \Delta }} :: VCtx ::= {{ com Variable Context }}
    | empty               ::   :: em  {{ tex \cdot }}
    | D , x : A           ::   :: vn

  Psi {{ tex \Psi }} :: HCtx ::= {{ com Quantum Heap Context }}
    | empty               ::   :: em  {{ tex \cdot }}
    | Psi , h             ::   :: vn
    | h                   :: S :: alone

  Gm {{ tex \Gamma }} :: ACtx ::= {{ com Assertion Context }}
    | empty               ::   :: em  {{ tex \cdot }}
    | Gm , P              ::   :: vn
    | P                   :: S :: alone

  terminals :: 'terminals_' ::=
    | \                   ::   :: lambda     {{ tex \lambda }}
    | -->                 ::   :: red        {{ tex \longrightarrow }}
    | ==>                 ::   :: seqimp     {{ tex \Longrightarrow }}
    | ==>b                ::   :: bred       {{ tex \Longrightarrow_\beta }}
    | ==>e                ::   :: expand     {{ tex \Longrightarrow_\eta }}
    |  ->                 ::   :: arrow      {{ tex \rightarrow }}
    | <-                  ::   :: larrow     {{ tex \leftarrow }}
    | <=                  ::   :: lbarrow    {{ tex \Leftarrow }}
    |  =>                 ::   :: rbarrow    {{ tex \Rightarrow }}
    | <                   ::   :: langle     {{ tex \langle }}
    | >                   ::   :: rangle     {{ tex \rangle }}
    | |-                  ::   :: turnstile  {{ tex \vdash }}
    | syn                 ::   :: syn        {{ tex \textcolor{red}{\stackrel{\rightarrow}{\in} } }}
    | chk                 ::   :: chk        {{ tex \textcolor{blue}{\stackrel{\leftarrow}{\in} } }}
    | in                  ::   :: in         {{ tex \in }}
    | Pi                  ::   :: pi         {{ tex \Pi }}
    | otimes              ::   :: otimes     {{ tex \otimes }}
    | top                 ::   :: top        {{ tex \top }}
    | bot                 ::   :: bot        {{ tex \bot }}
    | /\                  ::   :: and        {{ tex \wedge }}
    | \/                  ::   :: or         {{ tex \vee }}
    | imp                 ::   :: imp        {{ tex \supset }}
    | not                 ::   :: not        {{ tex \neg }}
    | ex                  ::   :: exists     {{ tex \exists }}
    | all                 ::   :: forall     {{ tex \forall }}
    | Id_A                ::   :: IdA        {{ tex \mathbf{Id}_A }}
    | =_A                 ::   :: AssA       {{ tex =_A }}
    | -o                  ::   :: Lollipop   {{ tex \multimap }}

  formula :: 'formula_' ::=
    | judgement           ::   :: judgement
    | not ( formula )     ::   :: not
    | x = x'              ::   :: eqv
    | x : A in D          ::   :: xAD


freevars
  M x :: fv

defns
  Jtype :: '' ::=

defn
    D |- A chk type :: :: Type :: Type {{ com $[[A]]$ is a well-formed type }} by

defn
    D |- K syn A :: :: TElim :: TElim         {{ com Elim term $[[K]]$ synthesizes type $[[A]]$ }} by

    ----------------- :: Var
    D, x:A |- x syn A

    D |- K syn Pi x:A.B
    D |- M chk A
    --------------------- :: Pi
    D |- K M syn [M/x](B)

   D |- A chk type
   D |- M chk A
   -------------- :: Annot
   D |- M:A syn A

defn
    D |- M chk A :: :: TIntro :: TIntro       {{ com Intro term $[[M]]$ checks against type $[[A]]$ }} by

    ---------------- :: Unit
    D |- () chk Unit

    D, x:A |- M chk B
    ---------------------- :: Pi
    D |- \x.M chk Pi x:A.B

    D; HId(init, mem) /\ P |- E chk x:A.Q
    ------------------------------------- :: Hoare
    D |- do E chk {P}x:A{Q}

    D; this(init) /\ ex D'.Psi.(R1 * top) |- E chk x:A. all D'.Psi.R1 -o R2
    ----------------------------------------------------------------------- :: DoE
    D |- do E chk D'.Psi.{R1} x:A {R2}

defn
    D ; P |- E syn x : A . Q :: :: SPC :: SPC {{ com $[[E]]$ synthesizes strongest postcondition $[[Q]]$ }} by

    D |- M chk A
    ------------------------------------------- :: return
    D; P |- return M syn x:A. P /\ Id_A(x, M)

defn
    D ; P |- E chk x : A . Q :: :: PC :: PC   {{ com $[[E]]$ satisfies postcondition $[[Q]]$ }} by

    D; P |- E syn x:A.R
    D, x:A; init, mem; R ==> Q
    -------------------------- :: consq
    D; P |- E chk x:A.Q

defn
    D ; Psi ; Gm1 ==> Gm2 :: :: SeqImp :: SeqImp by

    D; Psi; Gm1 ==> Gm2, P
    D; Psi; Gm1, P ==> Gm2
    ---------------------- :: Cut
    D; Psi; Gm1 ==> Gm2

    ------------------------------- :: ReflEqR
    D; Psi; Gm1 ==> Gm2, Id_A(M, M)

    ------------------------------- :: HReflEqR
    D; Psi; Gm1 ==> Gm2, HId(H, H)
defns
  Jop :: '' ::=

    defn
    M ==>b M' ::  :: reduce :: 'B'       {{ com $[[M]]$ beta reduces to $[[M']]$ }} by

    ------------------------------- :: AppAbs
    (\x.M:Pi x:A.B) N ==>b [N:A/x]M

    defn
    M ==>e M' ::  :: expand :: 'E'       {{ com $[[M]]$ eta expands to $[[M']]$ }} by

    ---------------- :: Unit
    M : Unit ==>e ()

    -------------------------------- :: Abs
    M:Pi x:A.B ==>e \y.(M:Pi x:A.B)y

    -------------------------------------- :: Comp
    K:{P}x:A{Q} ==>e do (x <- K; return x)

    defn
    E ==>b E' ::  :: creduce :: 'B'       {{ com Computation $[[E]]$ beta reduces to $[[E']]$ }} by

    ------------------------------------- :: Comp
    x <- do E:{P}x:A{Q}; F ==>b <E/x:A> F
