metavar termvar, x, y ::=
  {{ tex \mathit{[[termvar]]} }} {{ com term variable }}
metavar heapvar, h, init, mem ::=
  {{ tex \mathit{[[heapvar]]} }} {{ com heap variable }}


grammar
  A, B :: Ty ::=                                        {{ com Types }}
    | Unit                ::   :: Unit                    {{ com unit }}
    | Bool                ::   :: Bool                    {{ com booleans }}
    | Qbit                ::   :: Qubit                   {{ com qubits }}
    | U                   ::   :: Unitary                 {{ com unitary }}
    | A otimes B                  ::   :: pair                    {{ com product }}
    | Pi x : A . B                ::   :: Pi    (+ bind x in B +) {{ com dependent function }}
    | A -> B                      :: S :: arrow                   {{ com function }}
    | D . Psi . { P } x : A { Q } ::   :: Hoare (+ bind x in Q +) {{ com hoare type }}
    | { P } x : A { Q }   :: S :: HoareS
    | ( A )               :: S :: paren

  P, Q, R :: Ass ::= {{ com Assertions }}
    | top                 ::   :: Top
    | bot                 ::   :: Bot
    | P /\ Q              ::   :: And
    | P \/ Q              ::   :: Or
    | P imp Q             ::   :: Imply
    | not P               ::   :: Not
    | ex x : A . P        ::   :: Exists  (+ bind x in P +)
    | all x : A . P       ::   :: Forall  (+ bind x in P +)
    | ex h : heap . P     ::   :: ExistsH (+ bind h in P +)
    | all h : heap . P    ::   :: ForallH (+ bind h in P +)
    | Id_A ( M , N )      ::   :: TermId
    | HId ( H , G )       ::   :: HeapId
    | indom ( H , M )     ::   :: InDomain
    | seleq ( H , M , N ) :: S :: SelEq

  H, G :: Heap ::= {{ com Quantum Heaps }}
    | h                   ::   :: HeapVar
    | emp                 ::   :: Empty
    | upd ( H , M , N )   ::   :: Update
    | [ H / h ]           :: S :: hsub

  K, L :: ElimTm ::=                                    {{ com Elim Terms }}
    | x                   ::   :: Var                     {{ com variable }}
    | K M                 ::   :: App                     {{ com application }}
    | M : A               ::   :: Annot
    | ( K )               :: S :: paren
    | [ K / x ] M         :: M :: tsub

  M, N :: IntroTm ::=                                   {{ com Intro Terms }}
    | K                   ::   :: Elim
    | \ x . M             ::   :: Lam  (+ bind x in M +)  {{ com abstraction }}
    | ()                  ::   :: unit
    | do E                ::   :: Computation
    | true                ::   :: True
    | false               ::   :: False

  c :: Cmd ::= {{ com Quantum Commands }}
    | mkQbit M    :: :: init
    | applyU M    :: :: apply
    | measQbit M  :: :: measure
    | ifQ M N     :: :: control

  E, F :: Comp ::=  {{ com Computations }}
    | return M        ::   :: lift
    | x <- K ; E      ::   :: bindK     (+ bind x in E +)
    | x <= c ; E      ::   :: bindC     (+ bind x in E +)
    | x =_A M ; E     ::   :: bindPure  (+ bind x in E +)
    | ( E )           :: S :: paren
    | < E / x : A > F :: M :: msub                        {{ com monadic substitution }}

  D {{ tex \Delta }} :: VCtx ::= {{ com Variable Context }}
    | empty               ::   :: em  {{ tex \cdot }}
    | D , x : A           ::   :: vn 

  Psi {{ tex \Psi }} :: HCtx ::= {{ com Quantum Heap Context }}
    | empty               ::   :: em  {{ tex \cdot }}
    | Psi , h             ::   :: vn
    | h                   :: S :: single

  Gm {{ tex \Gamma }} :: ACtx ::= {{ com Assertion Context }}
    | empty               ::   :: em  {{ tex \cdot }}
    | Gm , P              ::   :: vn
    | P                   :: S :: single

  terminals :: 'terminals_' ::=
    | \                   ::   :: lambda     {{ tex \lambda }}
    | -->                 ::   :: red        {{ tex \longrightarrow }}
    | ==>                 ::   :: seqimp     {{ tex \Longrightarrow }}
    | ==>b                ::   :: bred       {{ tex \Longrightarrow_\beta }}
    | ==>e                ::   :: expand     {{ tex \Longrightarrow_\eta }}
    |  ->                 ::   :: arrow      {{ tex \rightarrow }}
    | <-                  ::   :: larrow     {{ tex \leftarrow }}
    | <=                  ::   :: lbarrow    {{ tex \Leftarrow }}
    |  =>                 ::   :: rbarrow    {{ tex \Rightarrow }}
    | <                   ::   :: langle     {{ tex \langle }}
    | >                   ::   :: rangle     {{ tex \rangle }}
    | |-                  ::   :: turnstile  {{ tex \vdash }}
    | in                  ::   :: in         {{ tex \in }}
    | Pi                  ::   :: pi         {{ tex \Pi }}
    | otimes              ::   :: otimes     {{ tex \otimes }}
    | top                 ::   :: top        {{ tex \top }}
    | bot                 ::   :: bot        {{ tex \bot }}
    | /\                  ::   :: and        {{ tex \wedge }}
    | \/                  ::   :: or         {{ tex \vee }}
    | imp                 ::   :: imp        {{ tex \supset }}
    | not                 ::   :: not        {{ tex \neg }}
    | ex                  ::   :: exists     {{ tex \exists }}
    | all                 ::   :: forall     {{ tex \forall }}
    | Id_A                ::   :: IdA        {{ tex Id_A }}
    | =_A                 ::   :: AssA       {{ tex =_A }}

  formula :: 'formula_' ::=          
    | judgement           ::   :: judgement
    | not ( formula )     ::   :: not  
    | x = x'              ::   :: eqv 
    | x : A in D          ::   :: xAD 


freevars
  M x :: fv 

defns
  Jtype :: '' ::= 

defn
    D |- K => A [ N' ] :: :: TElim :: TElim         {{ com Elim term $[[K]]$ has type $[[A]]$,
                                                           and canonical form $[[N']]$ }} by
    ------------------- :: Var
    D, x:A |- x => A[x]

defn
    D |- M <= A [ M' ] :: :: Tintro :: TIntro       {{ com Intro term $[[M]]$ has type $[[A]]$,
                                                           and canonical form $[[M']]$ }} by
    ------------------- :: Unit
    D |- () <= Unit[()]

    D, x:A |- M <= B[M']
    --------------------------- :: Pi
    D |- \x.M <= Pi x:A.B[\x.M']

defn
    D ; P |- E => x : A . Q [ E' ] :: :: SPC :: SPC {{ com $[[E]]$ has strongest postcond. $[[Q]]$
                                                           and canonical form $[[E']]$ }} by

defn
    D ; P |- E <= x : A . Q [ E' ] :: :: PC :: PC   {{ com $[[E]]$ has postcond. $[[Q]]$
                                                           and canonical form $[[E']]$ }} by
    D; P |- E => x:A.R[E']
    D, x:A; init, mem; R ==> Q
    -------------------------- :: Consequent
    D; P |- E <= x:A.Q[E']

defn
    D ; Psi ; Gm1 ==> Gm2 :: :: SeqImp :: SeqImp_ by

defns
  Jop :: '' ::=

    defn
    M ==>b M' ::  :: reduce :: 'B'       {{ com $[[M]]$ beta reduces to $[[M']]$ }} by

    ------------------------------- :: AppAbs
    (\x.M:Pi x:A.B) N ==>b [N:A/x]M

    defn
    M ==>e M' ::  :: expand :: 'E'       {{ com $[[M]]$ eta expands to $[[M']]$ }} by

    ---------------- :: Unit
    M : Unit ==>e ()

    -------------------------------- :: Abs
    M:Pi x:A.B ==>e \y.(M:Pi x:A.B)y

    -------------------------------------- :: Comp
    K:{P}x:A{Q} ==>e do (x <- K; return x)

    defn
    E ==>b E' ::  :: creduce :: 'B'       {{ com Computation $[[E]]$ beta reduces to $[[E']]$ }} by

    ------------------------------------- :: Comp
    x <- do E:{P}x:A{Q}; F ==>b <E/x:A> F