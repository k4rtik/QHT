\documentclass[acmsmall,nonacm,timestamp]{acmart}

\acmJournal{PACMPL}

\bibliographystyle{ACM-Reference-Format}
\citestyle{acmauthoryear}

\usepackage{booktabs}
\usepackage{subcaption}

\usepackage[braket]{qcircuit}
\usepackage{mathpartir}
\usepackage{mathtools}
\usepackage{xspace}
\usepackage{cleveref}
\crefformat{section}{\S#2#1#3}

\usepackage{color}
\definecolor{ltblue}{rgb}{0,0.4,0.4}
\definecolor{dkblue}{rgb}{0,0,1}
\definecolor{dkgreen}{rgb}{0,0.35,0}
\definecolor{dkviolet}{rgb}{0.3,0,0.5}
\definecolor{dkred}{rgb}{0.5,0,0}

\usepackage{listings}
\lstloadlanguages{Haskell}
\lstdefinelanguage{QHaskell}{
	language     = Haskell,
	morekeywords = {Qbit, U, C, Pure},
}

\lstset{
	basicstyle=\small\ttfamily,
	flexiblecolumns=false,
	basewidth={0.5em,0.45em},
	commentstyle=\color{dkgreen},
	keywordstyle=\bfseries\color{dkblue},
	stringstyle=\color{dkviolet},
	literate={+}{{$+$}}1 {/}{{$/$}}1 {*}{{$*$}}1 {=}{{$=$}}1
	{>}{{$>$}}1 {<}{{$<$}}1 {\\}{{$\lambda$}}1
	{\\\\}{{\char`\\\char`\\}}1
	{->}{{$\rightarrow$}}2 {>=}{{$\geq$}}2 {<-}{{$\leftarrow$}}2
	{<=}{{$\Leftarrow$}}2 {=>}{{$\Rightarrow$}}2
	{\ .}{{$\circ$}}2 {\ .\ }{{$\circ$}}2
	{>>}{{>>}}2 {>>=}{{>>=}}2
	{|}{{$\vert$}}1 {\\>}{{$\rangle$}}1
	{/\\}{{$\wedge$}}1 {\\/}{{$\vee$}}1
	{\\in}{{$\in$}}1 {\\o}{{$\circ$}}1 {\\Pi}{{$\Pi$}}1
	{|->}{{$\mapsto$}}2 {-o}{{$\multimap$}}2
}

\newcommand{\sqir}{\ensuremath{s\textsc{qir}}\xspace}
\newcommand{\qwire}{\ensuremath{\mathcal{Q}\textsc{wire}}\xspace}
\newcommand{\denote}[1]{\llbracket #1 \rrbracket\xspace}
\newcommand{\qdenote}[1]{(\!| #1 |\!)\xspace}

\newcommand{\type}[1]{\textrm{\textbf{#1}}}
\newcommand{\kw}[1]{\,\mathrm{\texttt{#1}}\,}
\newcommand{\todo}[1]{\textcolor{red}{#1}}

\title{Quantum Hoare Type Theory}
\subtitle{Master's Paper}

\author{Kartik Singhal}
\orcid{0000-0003-1132-269X}
\affiliation{
	\position{PhD Student}
	\department{Department of Computer Science}
	\institution{University of Chicago}
	\state{IL}
%	\postcode{60637}
	\country{USA}}
\email{ks@cs.uchicago.edu}

\authornote{Homepage: \url{http://ks.cs.uchicago.edu}}

%\authorsaddresses{}

\begin{document}

\begin{abstract}
	% Foreward
	%Context and Need
	As quantum computers become real, it is high time we come up with effective techniques that help programmers write correct quantum programs.
	%Need
	In classical computing, formal verification and sound static type systems prevent several classes of bugs from being introduced. There is a need for similar techniques in the quantum regime.
	%Task
	Inspired by Hoare Type Theory in the classical paradigm, we propose Quantum Hoare Types by extending the Quantum IO Monad by indexing it with pre- and post-conditions that serve as program specifications.
	%Object
	In this paper, we introduce Quantum Hoare Type Theory (QHTT), present its syntax and typing rules, and demonstrate its effectiveness with the help of examples.
	% Summary
	%Findings

	%Conclusion
	QHTT has the potential to be a unified system for programming, specifying, and reasoning about quantum programs.
	%Perspectives
%	This is a work in progress.
%Quantum Computing is a new and upcoming way to utilize quantum mechanics for computation. It is easy to introduce bugs while programming quantum computers similar to classical computing. Strong static type systems have prevented a lot of bugs from being introduced in the classical paradigm. There is a similar need for well-designed static types in the domain of quantum computing. We propose Quantum Hoare Types that let programmers reason statically about certain semantic properties of their quantum programs and further allow a limited form of formal verification.
\end{abstract}

\maketitle

\renewcommand*\contentsname{Table of Contents}
\tableofcontents

%\listoffigures

%\newpage

\section{Introduction}
It is difficult to reason about the correctness of quantum programs. Sound static type systems help prevent a huge class of bugs from occurring but since the realm of quantum programming is still new there is not a lot of consensus on what kind of types make the most sense. Further, it is unclear how much they help programmers reason about the semantic properties associated with the quantum algorithms that they are implementing.

Recent work~\cite{huang_qdb:_2018,huang_statistical_2019} as part of EPiQC\footnote{EPiQC: Enabling Practical-Scale Quantum Computation:  \url{https://epiqc.cs.uchicago.edu}} has identified several classes of bugs in quantum programs and proposed approaches to tackle them. The technique that holds the most promise is assertion checking using preconditions and postconditions. But assertions are usually checked dynamically during runtime, which can be wasteful of precious quantum computing or simulation resources.

As programming languages researchers, we think it will be better to encode such assertions into a static type system both for formal verification and to aid the programmers in writing correct programs from the start. Inspired by the use of Hoare triples in the verification of imperative programs and building on the idea of Hoare Type Theory (HTT) for classical programming languages~\cite{nanevski_hoare_2008}, we propose Quantum Hoare Type Theory (by extending the Quantum IO Monad interface\cite{qio}) aimed at enabling both sound static type checking and formal verification of quantum programs.

The main idea is that instead of just indexing the QIO monad type with the type of computation result, we can also index it with pre-conditions and post-conditions so as to integrate Hoare-style reasoning into the type system itself. The resulting Quantum Hoare Type, $\{P\} x{ : }A \{Q\}$, specifies the preconditions, $P$, that hold on the quantum state before execution; the result, $x$, and its type, $A$, on successful execution; and, the postconditions, $Q$, that are true for the quantum state after successful execution. In this way the effectful quantum fragment of the program is effectively encapsulated inside the Quantum Hoare monad. Our theory, like HTT, allows the usual equational reasoning for the pure classical fragments of the program and uses syntax-directed type checking for generating strongest postconditions for the quantum fragment.

This paper is organized as follows. We discuss background in the next section (\cref{sec:bg}); specifically, quantum computing (\cref{sec:qc}),  Hoare Type Theory in the classical setting (\cref{sec:htt}) and then the Quantum IO Monad interface (\cref{sec:qio}). Then we introduce our contributions in merging these ideas together for specification and enforcement of useful semantic properties in section \cref{sec:qhtt} along with its syntax (\cref{sec:syntax}), typing (\cref{sec:typing}) and, some examples (\cref{sec:examples}). Some related work follows in \cref{related}. Finally, we conclude and share ideas for future work in the final section (\cref{sec:conclusion}).

\section{Background}
\label{sec:bg}
In this section, we provide background on the core ideas from existing literature that form the foundation for our work -- Hoare Type Theory (HTT) and the Quantum IO Monad interface. We start with some basics of quantum computing.
% and refer the reader to Nielsen's excellent series of essays~\cite{matuschak2019} for a first introduction and to the standard textbook~\cite{nielsen2010} for advanced material.

\subsection{Quantum Computing}
\label{sec:qc}
The basic unit of information in quantum computing is a qubit, that can be represented using a unit vector in a two-dimensional complex vector space. Using Dirac's bra-ket notation, we can write an arbitrary qubit, $\ket{\psi}$, as a linear combination of the computational basis vectors: $\ket{\psi} = \alpha\ket{0} + \beta\ket{1}$, where $\ket{0}=\begin{bsmallmatrix}
1 \\
0
\end{bsmallmatrix}$ and $\ket{1}=\begin{bsmallmatrix}
0 \\
1
\end{bsmallmatrix}$, and the two constants are complex amplitudes that are normalized using the constraint $|\alpha|^2 +|\beta|^2 = 1$. This means that when measured, the probability of the qubit being in the state 0 is $|\alpha|^2$ and that for the state 1 is $|\beta|^2$. To work with multiple qubits, we need to take their tensor product, denoted by $\otimes$. Computation is performed by the application of unitary quantum gates, such as the Hadamard (H) gate or the controlled NOT (CX) gate, that can be represented as square matrices. Mathematically, a gate application is equivalent to multiplying the matrix representing the gate with the state vector of the qubit(s).

This basic unit of information is not the only reason why quantum computing is fundamentally different from classical computing---certain quantum mechanical phenomenon are highly counterintuitive! One such phenomenon is \textit{quantum entanglement} which, at its most basic level, involves a correlation between two qubits such that when one is measured, the outcome obtained necessarily influences the measurement outcome of the other qubit (even if the two qubits are far apart). %We will see how this property can be utilized for computation in the quantum teleportation algorithm that we describe and program in \S\ref{telep}.
We refer the reader to the standard textbook~\cite{nielsen_quantum_2010} or Nielsen's excellent series of essays~\cite{matuschak2019} for more background.

\subsection{Hoare Type Theory}
\label{sec:htt}
A Hoare type encodes preconditions and postconditions in the same spirit as Hoare triples to allow both specification and verification of effectful classical programs. The type shown on the left below can be read as `for a stateful computation executed in a heap that satisfies precondition $P$, return a value of type $A$ in a heap that satisfies postcondition $Q$.' We show an example, the \texttt{alloc} primitive from HTT~\cite{nanevski_hoare_2008}, to demonstrate the expressiveness of a Hoare type:
\begin{mathpar}
	\{P\}\; \texttt{x}:A\; \{Q\}

	\and

	\texttt{alloc} : \forall \alpha. \Pi x:\alpha. \{\texttt{emp}\}\; y:\texttt{nat}\; \{y \mapsto_{\alpha} x\}
\end{mathpar}

Type checking in HTT involves generation of strongest postconditions at each step of the program. Verification is a two-step process: the first phase does basic type checking and verification condition generation which is decidable, the second phase needs to show the validity of the generated verification conditions, which is undecidable. This second phase can be deferred to an automated theorem prover.

We provide more details when we introduce QHTT in section \cref{sec:qhtt}.

\subsection{Quantum IO Monad}
\label{sec:qio}

The Quantum IO (QIO) monad~\cite{qio} is a purely functional interface for quantum programming that provides a separation between the unitary (reversible) and non-unitary (irreversible) fragments of quantum computation. It provides isolation of quantum effects inside a monad similar to what we need to provide in our Quantum Hoare monad.

Here we discuss the relevant bits from the QIO interface. QIO provides a type for referring to qubits, \texttt{Qbit}; a type for unitary operations, \texttt{U}; and, the \texttt{QIO} type operator which is a monad indexed by the result of the quantum computation. The primitive quantum operations defined using the QIO monad below (Haskell syntax) are:
\begin{lstlisting}[language=QHaskell]
mkQbit : Bool -> QIO Qbit       -- initialization
applyU : U -> QIO ()            -- apply a unitary to quantum state
measQbit : Qbit -> QIO Bool     -- measurement
\end{lstlisting}

Further, \texttt{U} is defined as a monoid with neutral element, \texttt{mempty}, and operation, \texttt{mappend}, that encodes reversible operations on quantum state. Here are the core unitary primitives that we will need:

\begin{lstlisting}[language=QHaskell]
rot :: Qbit -> ((Bool, Bool) -> C) -> U
cond :: Qbit -> (Bool -> U) -> U
\end{lstlisting}

Here, \texttt{rot} takes a qubit and a two-by-two complex-valued unitary matrix (represented as a function from the matrix indices to $\mathbb{C}$) and lets one define arbitrary rotation on a single qubit. \texttt{rot} can then be used to define standard gates such as the hadamard, H, and the Pauli gates, X, Y and Z. \texttt{cond} is the unitary conditional that is used to perform branching unitary operations. For the present paper, we use a simpler conditional, \texttt{ifQ}, that is defined as follows:

\begin{lstlisting}[language=QHaskell]
ifQ :: Qbit -> U -> U
ifQ q u = cond q (\x -> if x then u else mempty)
\end{lstlisting}

That is, \texttt{ifQ} acts as the standard control operator in the quantum circuit model that runs its second argument based on the truth value of its first argument. Then, it is easy to define controlled gates such as CNOT with the expression $\kw{ifQ q1 (X q2)}$.

Quantum state in the QIO interface is modeled as a normalized vector that intuitively stores pairs representing complex amplitudes associated with each basis state (represented as a map from Qbit to Bool types). The operations defined over the vector class ensure that the quantum state is kept normalized throughout.

QIO further ensures that the monoidal structure of unitary operations lets one run a unitary operation over the complete quantum state. We elide details here and refer the reader to \cite{qio} for more.

%\subsection{Hoare Style Reasoning}
%\textit{Basics of Hoare-triples for non-specialists\ldots}
%
%\subsection{Program Proof and HTT}
%\textit{Basics of program proof and techniques for non-specialists\ldots}

\section{Quantum Hoare Type Theory}
\label{sec:qhtt}
In this section, we introduce the Quantum Hoare Type inspired by the QIO monad and its type theory (QHTT) by replacing the classical effectful portion of Hoare Type Theory with quantum effects. The core idea is to encapsulate any quantum effect inside a monadic Quantum Hoare type, $\Delta. \Psi .\{P\} x{ : }A \{Q\}$, and formalize reasoning of quantum effects using strongest postconditions in a similar fashion as HTT in the classical setting.

The next two sections discuss the syntax and typing of QHTT. The last section show examples written in QHTT.

\subsection{Syntax}
\label{sec:syntax}

Figure \ref{fig:syntax} shows the syntax of Quantum Hoare Type Theory. Our presentation closely follows that of HTT~\cite{nanevski_hoare_2008}.

Complete grammar written using Ott tool at \url{https://github.com/k4rtik/QHT/blob/master/ott/qhtt.ott}.

\begin{figure}[ht]
	\begin{tabular}{lrcl}
		\textit{Types} & $A, B, C$ & ::= &
		\begin{minipage}[t]{0.45\columnwidth}%
			$ \type{1} \mid \type{Bool} \mid \type{Qbit} \mid \type{U} \mid \type{Pure} \mid A \otimes B \mid \Pi x{ : }A.B \mid \Delta. \Psi .\{P\} x{ : }A \{Q\}$
		\end{minipage}\\ \\
		\textit{Assertions} & $P, Q, R$ & ::= &
		\begin{minipage}[t]{0.45\columnwidth}%
			$ \top \mid \bot \mid P \wedge Q \mid P \vee Q \mid P \supset Q \mid \neg P \mid \exists x{:}A.P \mid \forall x{:}A.P \mid \exists h{:}\kw{heap}.P \mid \forall h{:}\kw{heap}.P \mid \kw{Id}_A(M, N) \mid \kw{HId}(H, G) \mid \kw{indom}(H,M) $
		\end{minipage}\\ \\
		\textit{Q. Heaps} & $H, G$ & ::= & $ h \mid \kw{empty} \mid \kw{upd}(H, M, N) $\\ \\
		\textit{Elim terms} & $K, L$ & ::= & $ x \mid K M \mid M : A $\\
		\textit{Intro terms} & $M, N, O$ & ::= & $ K \mid () \mid \lambda x.M \mid \kw{do} E \mid \kw{true} \mid \kw{false} $\\ \\
		\textit{Q. Commands} & $c$ & ::= &
		\begin{minipage}[t]{0.45\columnwidth}%
			$ \kw{mkQbit} M \mid \kw{measQbit} M \mid \kw{applyU} M \mid \kw{if} M \kw{then} N \kw{else} O$
		\end{minipage}\\
		\textit{Computations} & $E, F$ & ::= & $ \kw{return} M \mid x \leftarrow K; E \mid x \Leftarrow c; E \mid x =_A M; E $\\ \\
		\textit{Variable context} & $\Delta$ & ::= & $ \cdot \mid x : A, \Delta $ \\
		\textit{Q. Heap context} & $\Psi$ & ::= & $ \cdot \mid h, \Psi$ \\
		\textit{Assertion context} & $\Gamma$ & ::= & $ \cdot \mid P, \Gamma$ \\
	\end{tabular}
	\Description{Syntax of Quantum Hoare Type Theory}
	\caption{Syntax of Quantum Hoare Type Theory}
	\label{fig:syntax}
\end{figure}

\paragraph{Types} We include primitive types for unit, booleans, qubits and unitary operations, and a type \type{Pure} for representing pure quantum state vectors (complex valued vectors in Hilbert space); these correspond to similar types in the QIO work. There are also type constructors for pairs, dependent functions and the Hoare type from HTT.

\paragraph{Assertions}
Apart from the usual first order logic, we have assertions for reasoning about propositional equality of terms, $\kw{Id}_A(M, N)$, and heaps, $\kw{HId}(H, G)$.

As done in HTT, some common convenience assertions can be defined using the base primitives. Particularly, $\kw{emp}$ denotes that the heap is empty. M $\mapsto$ N represents that this is the only mapping in the heap. M $\hookrightarrow$ N represents that looking up M in the heap returns N. $\kw{seleq}$(H, M, N) asserts that in heap H, location M points to N.

\paragraph{Quantum State}

We use the terms quantum state and quantum heaps interchangeably throughout. A quantum heap is a partial function from qubits (that can in turn be thought of as locations, represented using natural numbers) to at most one quantum state vector.

For the purpose of the type theory, heaps are functional, so that, for example, $\kw{upd}(H, M, N)$ returns a new heap after updating heap H at location M with N.

\paragraph{Terms}
The terms are divided into introduction and elimination sorts for the purpose of bidirectional typechecking like in HTT.

The pure fragment allows higher-order functions while the impure (effectful) fragment is encapsulated within the monadic \texttt{do} $E$ construct and supports a simple imperative quantum language inspired by QIO constructs. It is worth noting that \texttt{do} $E$ represents suspended computation and is considered pure.

\paragraph{Quantum Commands}
These are the quantum-specific effectful commands from QIO for initialization, unitary application and measurement of qubits. We also support classical control using the \texttt{if} $M$ \texttt{then} $N$ \texttt{else} $O$ construct similar to HTT.

\paragraph{Computations} The computations are the usual monadic return and (three) bind operations as in HTT.

\paragraph{Contexts} Contexts are modelled exactly the same way as in HTT. The only difference is that instead of classical heaps, we have quantum heaps.

\subsection{Typing Rules}
\label{sec:typing}

In this section, we provide some details about type checking in HTT and how it is different in the quantum case.

\subsubsection{Judgments}
The type system is designed to be bidirectional and syntax directed and hences include separate judgements for intro and elim terms. We are able to use them unchanged for QHTT.

The type checking process also involves generating canonical forms for each term. A canonical form in HTT means a beta-normal (containing no beta-redexes) and eta-long (all intro terms are eta-expanded) form. We elide much detail here.

As usual elim terms synthesize types ($\Rightarrow$) and intro terms are checked against the given type ($\Leftarrow$). Canonical forms are always synthesized. For the pure fragment:

\begin{center}
	\begin{tabular}{ll}
		$\Delta \vdash K \Rightarrow A [N']$ & Elim term K has type A and canonical form $N'$ \\
		$\Delta \vdash M \Leftarrow A [M']$ & Intro term M has type A and canonical form $M'$
	\end{tabular}
\end{center}

The judgments for computations involve synthesizing the strongest postconditions and checking whether a given postcondition applies:

\begin{center}
	\begin{tabular}{ll}
		$\Delta; P \vdash E \Rightarrow x:A.Q[E']$ & Computation E with precondition P has \textit{strongest} postcondition Q\\ & and returns value x of type A. Its canonical form is $E'$. \\
		$\Delta; P \vdash E \Leftarrow x:A.Q[E']$ & Computation E with precondition P has postcondition Q\\ & and returns value x of type A. Its canonical form is $E'$.
	\end{tabular}
\end{center}

The type system includes rules for primitive effectful commands and those for structuring composition such as monadic unit and bind. We reuse most of the HTT rules except those for primitives for quantum effects that need to specify the strongest postconditions for each primitive, we discuss that next.

\subsubsection{Strongest Postconditions}
Here we show the strongest postconditions for the primitive quantum commands of QHTT encoded in their typing rules. Given a quantum command for initialization, unitary application or measurement, its strongest postcondition is an assertion that most precisely captures the relationship between the initial state and the modified state after the execution. These rules along with the \texttt{consq} (consequent) rule of HTT (that ensures weakening of the given strongest postcondition to an arbitrary postcondition) work together to ensure composition of verification.

We need to use the relational composition connective from HTT ($P \circ Q$) that captures how heap evolves with computation. It basically reads: $Q$ holds of the current heap which is obtained after modification of a prior heap for which P holds.

We also use HTT's difference operator ($\multimap$) below that captures changes to only the interesting fragment of the heap without modifying the rest of the heap.

We can now show some typing rules:

\paragraph{Initialization}
$x \Leftarrow \kw{mkQbit} M; E$

\begin{mathpar}
	\inferrule
	{\Delta \vdash M : \type{Bool}
		\\ \Delta, x : \type{Qbit}; P \circ (x \mapsto \kw{state}(M)) \vdash E \Rightarrow y:B . Q}
	{\Delta; P \vdash x \Leftarrow \kw{mkQbit} M; E \Rightarrow y:B. (\exists x:\type{Qbit}.Q)}
\end{mathpar}
where x is fresh and \texttt{state} is a function that translates a classical representation of quantum state (such as boolean here) to the equivalent quantum state vector.

\paragraph{Measurement}
$x \Leftarrow \kw{measQbit} M; E$

\begin{mathpar}
	\inferrule
	{\Delta \vdash M : \type{Qbit}
		\\ \Delta \vdash P \supset (M \hookrightarrow -)
		\\ \Delta; P \circ ((M \mapsto -) \multimap \kw{emp}) \vdash E \Rightarrow y:B . Q}
	{\Delta; P \vdash x \Leftarrow \kw{measQbit} M; E \Rightarrow y:B. Q}
\end{mathpar}

In measurement, we first need to ensure that the precondition P implies that M is allocated in the heap and that the fragment of heap that only refers to location M becomes empty.

As may be apparent, initialization and measurement are analogous to HTT's \texttt{alloc} and \texttt{dealloc} primitives. We are working out precise details for unitary application, but at a high-level, they involve ensuring that the given unitary term actually represents a unitary matrix and updating the quantum state with the result of unitary application. This involves incorporating the monoidal structure of unitaries into our theory (as is done in QIO). This step also involves generating verification conditions that cannot be checked during this first phase of typechecking.

\subsection{Sample programs}
\label{sec:examples}

In this section, we show some simple examples from the QIO work~\cite{qio} translated in our language and annotated with their program specifications using their Quantum Hoare types. An observation is that translating the programs was a very simple process except for coming up with the right specifications for the programs. We take some liberty in writing our typeset syntax as plain text for convenience and provide some commentary on assertions specified for these programs.

At the end of this section, we show a sample verification using QHTT for Bell pair generation.

\subsubsection*{Hello Quantum World}
\begin{lstlisting}[language=QHaskell]
hqw : {emp} r : Bool {emp /\ Id(r, false)}
    = do q <= mkQbit false;
         measQbit q
\end{lstlisting}

We start out in an empty state and assert that the result is equal to \texttt{false}.

\subsubsection*{Coin Toss}
\begin{lstlisting}[language=QHaskell]
rnd : {emp} r : Bool {emp}
    = do q <= mkQbit false;
         applyU (H q);
         measQbit q
\end{lstlisting}

As the result can be in either of its two values \texttt{false} or \texttt{true}, we need not specify any special postcondition as type checking the result will be sufficient for correctness.

\subsubsection*{Testing Bell Pair}
\begin{lstlisting}[language=QHaskell]
testBell : {emp} (a, b) : (Bool, Bool) {emp /\ Id(a, b)}  -- a,b \in {true, false}
         = do qa <= mkQbit false;
              applyU (H qa);
              qb <= mkQbit false;
              applyU (ifQ qa (X qb));
              (measQbit qa, measQbit qb)
\end{lstlisting}

Here, we are asserting that the returned booleans $a$ and $b$ hold the same value, which is what we expect from a Bell pair.

\paragraph{Verification}
We would like to describe how QHTT lets us verify the correctness of the above program based on the specification provided as the type of the function. For illustration, we show the assertions annotated as comments as we step through the \texttt{testBell} program below. We have elided specific details about unitary application and definition of the previously mentioned \texttt{state} function as they are still being worked out.

\begin{lstlisting}[language=QHaskell]
testBell : {emp} (a, b) : (Bool, Bool) {emp /\ Id(a, b)}
              -- P0: emp
         = do qa <= mkQbit false;
              -- P1: P0 \o (qa |-> state(false))
              applyU (H qa);
              -- P2: P1 \o (qa |-> state({(0.5, false), (0.5, true)}))
              qb <= mkQbit false;
              -- P3: P2 \o (qa |-> state(false))
              applyU (ifQ qa (X qb));
              -- P4: P3 \o ((qa, qb) |-> state({(0.5, (false, false),
              --                              (0.5, (true, true))}))
                (measQbit qa, measQbit qb)
              -- P5: P4 \o ((qa |-> -) -o emp) \o ((qb |-> -) -o emp)
\end{lstlisting}
Finally, the \texttt{consq} rule should ensure that the assertion P5 can lead to the specified postcondition in the type of the program.

We show some two more examples in the appendix for a modular version of Bell pair generation (\cref{app:mbp}) that shows use of higher-order features of QHTT and another for teleportation protocol (\cref{app:teleport}). Both of these involve specifying assertions over quantum state whose theory we still need to work out.

%\subsection{Soundness / Type Checking Algorithm}

%\section{Evaluation}

%\subsection{More Examples}
%\textit{add at least one example with scaling knob}

%\subsection{Circuit-complexity Considerations}

\section{Related Work}
\label{related}
%\textit{Objective of this section\ldots}

%\subsection{Quantum Languages and Types}
%\textit{A chronology of language developments wrt to usefulness of types\ldots}

\subsection{Verification of Quantum Programs}
Previous work, such as Proto-Quipper~\cite{ross_algebraic_2015,rios_categorical_2017} and \qwire~\cite{paykin_qwire:_2017,rand_qwire_2017,rand_formally_2018} utilize a linear type system and dependent types to enforce a small subset of semantic properties, such as the no-cloning restriction and whether a unitary gate is of the right dimension. These advances in quantum type systems, although helpful, still fall short in encoding and enforcing even more useful properties that one would like to be able to express for the purpose of verification.

Our approach builds upon previous work in reasoning about quantum programs such as Quantum Weakest Preconditions~\cite{dhondt_quantum_2006} and Quantum Hoare Logic~\cite{ying_floydhoare_2012} in the spirit of \citet{hoare_axiomatic_1969} and \citet{dijkstra_discipline_1976} but attempts to bring those reasoning techniques into the type system. The hope is that programmers will be able to encode some of the semantic properties that they expect of their programs as specifications in their code and type checking will ensure correctness of some of those properties. In the classical setting, Hoare Type Theory (HTT)~\cite{nanevski_hoare_2008} accomplishes exactly this goal. Our attempt is to merge these ideas for the quantum realm.

%\textit{Add from Mingsheng Ying's book, papers, etc.}

\section{Conclusion and Perspectives}
\label{sec:conclusion}
In this paper, we have described our ongoing work on Quantum Hoare Type Theory, which modifies HTT for quantum computing using ideas from the Quantum IO monad work. This approach has the potential to be a unified system for programming, specification, and reasoning about quantum programs. We need to overcome challenges such as compactly specifying properties of quantum state when dealing with more than a few qubits. We also need to maintain the syntax directed nature of HTT's bidirectional typechecking while incorporating quantum wire types.

There are several avenues of future work to explore:

\paragraph{Mechanization} There are multiple implementations of HTT in Coq such as Ynot~\cite{ynot2008}. We are similarly working on mechanizing QHTT in Coq for higher assurance of the usefulness and soundness of our theory. This will also enable us to extract verified circuits in a lower level quantum language such as OpenQASM for execution on real machines.

\paragraph{Quantum Assertion Logic} An obvious need is to come up with an assertion logic similar to Separation Logic~\cite{reynolds2002} for quantum computing so as to be able to reason about only the interesting portions of the quantum state while still ensuring correctness of non-local effects such as entanglement. Various Quantum Hoare Logics that exist~\cite{ying_floydhoare_2012} currently do not support frame rules that provide Separation Logic its power.

\paragraph{Linearity} Peter Selinger and collaborators have recently proposed a linear dependent typed version of Proto-Quipper (dubbed Proto-Quipper-D)~\cite{selinger2020}. It is an interesting challenge to reconcile linearity in our theory based on their proposal.

\paragraph{Circuits as Arrows} Further, Proto-Quipper treats quantum circuits as first class citizens of the language. We would like to explore modifying our theory to treat Quantum Hoare types as arrows instead of as monads as was suggested by Vizzotto et al~\cite{so-arrows}. It makes sense from the perspective of sequential composition as arrows can have an arbitrary number of input/outputs as opposed to monads.

\paragraph{Behavioural Types} Another venue for exploration is to incorporate more precise types that can distinguish between qubits in pure classical state vs. those in superposition vs. those in entanglement~\cite{JorrandPerdrix2009} such as those inspired by the various quantum resource theories (see \cite{rand_type_2019} and references therein). This may help us provide more specific postconditions that quantum programmers expect to hold true of their programs.

\paragraph{Classical Effects} Finally, it will be an interesting challenge to reconcile both classical and quantum effects together in a single grand unified theory for effects.

%\textit{Future work about using Proto-Quipper/\qwire as languages, then extraction into QASM and checking generated verification conditions.}

\begin{acks}
%	I would like to thank my advisor John Reppy for suggesting me to look at Hoare Type Theory that led to this master's thesis and for his constant support and encouragement to see it through. I also thank my committee members Fred Chong and Ravi Chugh for reading drafts of this document and providing useful feedback.

	This material is based upon work supported by
	EPiQC, an \grantsponsor{GS100000001}{NSF}{http://dx.doi.org/10.13039/100000001}
	Expedition in Computing, under Grant
	No.~\grantnum{GS100000001}{1730449}.  Any opinions, findings, and
	conclusions or recommendations expressed in this material are those
	of the authors and do not necessarily reflect the views of the
	National Science Foundation.
\end{acks}

\newpage

\bibliography{references}

\newpage

\newpage

\appendix

\section{Modular Bell Pair}
\label{app:mbp}
Writing a modular version of \texttt{testBell}.

\subsection{Hadamard basis states}
\begin{lstlisting}[language=QHaskell]
qplus : {emp} r : Qbit {Id(r, |+\>)}
      = do q <= mkQbit false;
           applyU (H q);
           return q

qminus : {emp} r : Qbit {Id(r, |-\>)}
       = do q <= mkQbit true;
            applyU (H q);
            return q
\end{lstlisting}

\subsection{Creating entanglement}
\begin{lstlisting}[language=QHaskell]
share : \Pi a : Qbit.
        {a \in {|+\>, |-\>}}   -- a \in {b, c} is short for Id(a,b) \/ Id(a,c)
           b : Qbit
        {Id(a, b) /\ a \in {|0\>, |1\>}}
      = \a.do b <= mkQbit false;
              applyU (ifQ a (X b));
              return b
\end{lstlisting}

\subsection{Bell pair}
\begin{lstlisting}[language=QHaskell]
bell : {emp} (a, b) : (Qbit, Qbit) {Id(a, b) /\ a \in {|0\>, |1\>}}
     = do qa <- qplus;
          qb <- share qa;
          return (qa, qb)
\end{lstlisting}

\subsection{Testing modular Bell pair}
\begin{lstlisting}[language=QHaskell]
testBell : {emp} (a, b) : (Bool, Bool) {emp /\ Id(a, b)}
         = do (qa, qb) <- bell;
              (measQbit qa, measQbit qb)
\end{lstlisting}

\section{Teleportation}
\label{app:teleport}
% \todo{TODO: Refine assertions}
\subsection{Alice's circuit}
\begin{lstlisting}[language=QHaskell]
alice : \Pi a : Qbit. \Pi e : Qbit
        {(Id(a, -) /\ entangled(e)}
           r : (Bool, Bool)
        {emp}
      = \a.\e.do applyU (ifQ a (X e));
                 applyU (H a);
                 (measQbit a, measQbit e)
\end{lstlisting}

\subsection{Bob's circuit}
\begin{lstlisting}[language=QHaskell]
bob : \Pi m1 m2 : Bool. \Pi e : Qbit
      {entangled(e)}
         r : Qbit
      {(Id(r, -)}
      = \m1.\m2.\e.do if m1 then applyU (Z e) else ();
                      if m2 then applyU (X e) else ();
                      return e
\end{lstlisting}

\subsection{Teleport}
\begin{lstlisting}[language=QHaskell]
teleport : \Pi q : Qbit. x : Pure.
      {Id(q, x)}
         r : Qbit
      {Id(r, x)}
      = \q.do (a, b) <- bell;
              (m1, m2) <- alice q a;
              tq <- bob m1 m2 b;
              return tq
\end{lstlisting}

%\section{Sample Proof}
%\textit{Coq code / Annotated proof objects from implementation\ldots}

\end{document}
