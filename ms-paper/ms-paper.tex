\documentclass[acmsmall,nonacm,timestamp,review=false,anonymous=false]{acmart}

\acmJournal{PACMPL}

\bibliographystyle{ACM-Reference-Format}
\citestyle{acmauthoryear}

\usepackage[braket]{qcircuit}
\usepackage{mathpartir}
\usepackage{mathtools}
\usepackage{xspace}
\usepackage{cleveref}
\crefformat{section}{\S#2#1#3}

\usepackage{rotating}

\definecolor{dkgreen}{rgb}{0,0.35,0}

\usepackage{listings}
\lstloadlanguages{Haskell}
\lstdefinelanguage{QHaskell}{
	language     = Haskell,
	morekeywords = {Qbit, U, C, meas, apply, to},
}

\lstset{
	basicstyle=\small\ttfamily,
	flexiblecolumns=false,
	basewidth={0.5em,0.45em},
	commentstyle=\color{dkgreen},
	keywordstyle=\bfseries\color{blue},
	stringstyle=\color{violet},
	literate={+}{{$+$}}1 {/}{{$/$}}1 {*}{{$*$}}1 {=}{{$=$}}1
	{>}{{$>$}}1 {<}{{$<$}}1 {\\}{{$\lambda$}}1
	{\\\\}{{\char`\\\char`\\}}1
	{->}{{$\rightarrow$}}2 {>=}{{$\geq$}}2 {<-}{{$\leftarrow$}}2
	{<=}{{$\Leftarrow$}}2 {=>}{{$\Rightarrow$}}2
	{\ .}{{$\circ$}}2 {\ .\ }{{$\circ$}}2
	{>>}{{>>}}2 {>>=}{{>>=}}2
	{|}{{$\vert$}}1 {\\>}{{$\rangle$}}1
	{/\\}{{$\wedge$}}1 {\\/}{{$\vee$}}1
	{\\in}{{$\in$}}1 {\\o}{{$\circ$}}1 {\\Pi}{{$\Pi$}}1
	{\\Phi+}{{$\Phi^+$}}2
	{|->}{{$\mapsto$}}2 {-o}{{$\multimap$}}2
	{o*}{{$\otimes$}}1
	{\\top}{{$\top$}}1
	{\\bot}{{$\bot$}}1
	{=q}{{$=_q$}}2
	{alpha}{{$\alpha$}}1 {beta}{{$\beta$}}1
}

\newcommand{\sqir}{\ensuremath{s\textsc{qir}}\xspace}
\newcommand{\qwire}{\ensuremath{\mathcal{Q}\textsc{wire}}\xspace}
\newcommand{\denote}[1]{\llbracket #1 \rrbracket\xspace}
\newcommand{\qdenote}[1]{(\!| #1 |\!)\xspace}

\newcommand{\type}[1]{\textrm{\textbf{#1}}}
\newcommand{\kw}[1]{\,\mathrm{\texttt{#1}}\,}
\newcommand{\todo}[1]{\textcolor{red}{#1}}

% modified from bidir-survey
\definecolor{dRed}{rgb}{0.85, 0.0, 0.0}
\definecolor{dBlue}{rgb}{0.0, 0.0, 0.85}

\newcommand{\chkcolor}{dBlue}
\newcommand{\syncolor}{dRed}
\newcommand{\chk}{\,\textcolor{\chkcolor}{{\stackrel{\leftarrow}{\in}}}\,}
\newcommand{\uncoloredsyn}{{{\stackrel{\rightarrow}{\in}}}}
\newcommand{\syn}{\,\textcolor{\syncolor}{\uncoloredsyn}\,}

\newcommand{\prove}{\models}

\title{Quantum Hoare Type Theory}
\subtitle{Master's Paper}

\author{Kartik Singhal}
\orcid{0000-0003-1132-269X}
\affiliation{
	\position{PhD Student}
	\department{Department of Computer Science}
	\institution{University of Chicago}
	\city{Chicago}
	\state{IL}
%	\postcode{60637}
	\country{USA}}
\email{ks@cs.uchicago.edu}

\authornote{Homepage: \url{http://ks.cs.uchicago.edu}}

%\authorsaddresses{}

\begin{document}

\begin{abstract}
	% Foreward
	%Context and Need
	As quantum computers become real, it is high time we come up with effective techniques that help programmers write correct quantum programs.
	%Need
	In classical computing, formal verification and sound static type systems prevent several classes of bugs from being introduced. There is a need for similar techniques in the quantum regime.
	%Task
	Inspired by Hoare Type Theory in the classical paradigm, we propose Quantum Hoare Types in which a quantum effect monad is indexed with pre- and post-conditions that serve as program specifications.
	%Object
	In this paper, we introduce Quantum Hoare Type Theory (QHTT), present its syntax and typing rules, and demonstrate its effectiveness with the help of examples.
	% Summary
	%Findings

	%Conclusion
	QHTT has the potential to be a unified system for programming, specifying, and reasoning about quantum programs.
	%Perspectives
%	This is a work in progress.
%Quantum Computing is a new and upcoming way to utilize quantum mechanics for computation. It is easy to introduce bugs while programming quantum computers similar to classical computing. Strong static type systems have prevented a lot of bugs from being introduced in the classical paradigm. There is a similar need for well-designed static types in the domain of quantum computing. We propose Quantum Hoare Types that let programmers reason statically about certain semantic properties of their quantum programs and further allow a limited form of formal verification.
\end{abstract}

\maketitle

\tableofcontents

%\listoffigures

%\newpage

\section{Introduction}
It is difficult to reason about the correctness of quantum programs. Sound static type systems help prevent a huge class of bugs from occurring but since the realm of quantum programming is still new there is not a lot of consensus on what kind of types make the most sense. Further, it is unclear how much they help programmers reason about the semantic properties associated with the quantum algorithms that they are implementing.

Recent work~\cite{huang_qdb:_2018,huang_statistical_2019} as part of EPiQC\footnote{EPiQC: Enabling Practical-Scale Quantum Computation:  \url{https://epiqc.cs.uchicago.edu}} has identified several classes of bugs in quantum programs and proposed approaches to tackle them. The technique that holds the most promise is assertion checking using preconditions and postconditions. But assertions are usually checked dynamically during runtime, which can be wasteful of precious quantum computing or simulation resources.

As programming languages researchers, we think it will be better to encode such assertions (propositions) into a static type system both for formal verification and to aid the programmers in writing correct programs from the start.\footnote{In this work, we will use the terms \textit{proposition} and \textit{predicate} interchangeably to signify their static nature as opposed to the runtime nature of \textit{assertions}.} Inspired by the use of Hoare triples in the verification of imperative programs and building on the idea of Hoare Type Theory (HTT) for classical programming languages~\cite{nanevski_hoare_2008}, we extend a quantum effect monad inspired by the Quantum IO Monad interface~\cite{qio} and propose Quantum Hoare Type Theory aimed at enabling both sound static type checking and formal verification of quantum programs.

The main idea is that instead of just indexing the QIO monad type with the type of computation result, we can also index it with pre-conditions and post-conditions so as to integrate Hoare-style reasoning into the type system itself. The resulting Quantum Hoare Type, $\{P\}\ x{ : }A\ \{Q\}$, specifies the preconditions, $P$, that hold on the quantum state before execution; the result, $x$, and its type, $A$; and, the postconditions, $Q$, that are true for the quantum state after successful execution. In this way the effectful quantum fragment of the program is effectively encapsulated inside the Quantum Hoare monad. Our theory, like HTT, allows the usual equational reasoning for the pure classical fragments of the program and uses syntax-directed type checking for generating strongest postconditions for the quantum fragment.

This paper is organized as follows. We discuss background in the next section, \cref{sec:bg}; specifically, quantum computing (\cref{sec:qc}),  Hoare Type Theory in the classical setting (\cref{sec:htt}) and then the Quantum IO Monad interface (\cref{sec:qio}). Then we introduce our contributions in merging these ideas together for specification and enforcement of useful semantic properties in section~\cref{sec:qhtt} along with its syntax (\cref{sec:syntax}), typing rules (\cref{sec:typing}) and, some examples (\cref{sec:examples}). Some related work follows in \cref{sec:related}. Finally, we conclude and share ideas for future work in the final section (\cref{sec:conclusion}).

\section{Background}
\label{sec:bg}
In this section, we provide background on the core ideas from existing literature that form the foundation for our work --- Hoare Type Theory (HTT) and the Quantum IO Monad interface. We start with some basics of quantum computing.
% and refer the reader to Nielsen's excellent series of essays~\cite{matuschak2019} for a first introduction and to the standard textbook~\cite{nielsen2010} for advanced material.

\subsection{Quantum Computing}
\label{sec:qc}
The basic unit of information in quantum computing is a qubit, that can be represented using a unit vector in a two-dimensional complex vector space. Using Dirac's bra-ket notation, we can write an arbitrary qubit, $\ket{\psi}$, as a linear combination of the computational basis vectors: $\ket{\psi} = \alpha\ket{0} + \beta\ket{1}$, where $\ket{0}=\begin{bsmallmatrix}
1 \\
0
\end{bsmallmatrix}$ and $\ket{1}=\begin{bsmallmatrix}
0 \\
1
\end{bsmallmatrix}$, and the two constants are complex amplitudes that are normalized using the constraint $|\alpha|^2 +|\beta|^2 = 1$. This means that when measured, the probability of the qubit being in the state 0 is $|\alpha|^2$ and that for the state 1 is $|\beta|^2$. To work with multiple qubits, we need to take their tensor product, denoted by $\otimes$. Computation is performed by the application of unitary quantum gates, such as the Hadamard (H) gate or the controlled NOT (CX) gate, that can be represented as square matrices. Mathematically, a gate application is equivalent to multiplying the matrix representing the gate with the state vector of the qubit(s).

This basic unit of information is not the only reason why quantum computing is fundamentally different from classical computing---certain quantum mechanical phenomenon are highly counterintuitive! One such phenomenon is \textit{quantum entanglement} which, at its most basic level, involves a correlation between two qubits such that when one is measured, the outcome obtained necessarily influences the measurement outcome of the other qubit (even if the two qubits are far apart). %We will see how this property can be utilized for computation in the quantum teleportation algorithm that we describe and program in \S\ref{telep}.
We refer the reader to the standard textbook by \citet{nielsen_quantum_2010} or the excellent series of essays by \citet{matuschak2019} for more background.

\subsection{Hoare Type Theory}
\label{sec:htt}
A Hoare type, $\Delta.\Psi.\{P\}\; \texttt{x}:A\; \{Q\}$, encodes preconditions and postconditions in the same spirit as Hoare triples to allow both specification and verification of effectful classical programs. It can be read as `for a stateful computation executed in a heap that satisfies precondition $P$, return a value of type $A$ in a heap that satisfies postcondition $Q$.' The contexts, $\Delta$ and $\Psi$, contain the variables and heap variables that may appear in both $P$ and $Q$. In this presentation, we will omit the contexts in the Hoare type when they are unneeded. We show an example to demonstrate the expressiveness of a Hoare type --- the \texttt{alloc} primitive from HTT~\cite{nanevski_hoare_2008}:
\begin{mathpar}
	\texttt{alloc} : \forall \alpha. \Pi x:\alpha. \{\texttt{emp}\}\; y:\texttt{nat}\; \{y \mapsto_{\alpha} x\}
\end{mathpar}

This type specifies that \texttt{alloc} is a polymorphic function that takes as input a variable, $x$, of any simple type, $\alpha$, that is executed in an empty heap (meaning it does not affect existing heap), returns a new location bound by a fresh variable, $y$, of type \texttt{nat} and initializes it with the supplied value $x$ of type $\alpha$.

Type checking in HTT involves generation of strongest postconditions at each step of the program. Verification is a two-step process: the first phase does basic type checking and verification condition generation which is decidable, the second phase needs to show the validity of the generated verification conditions, which can be undecidable. This second phase can be deferred to an automated theorem prover.

We provide more details when we introduce QHTT in section~\cref{sec:qhtt}. An accessible introduction to Hoare Type Theory is available in the lecture notes by \citet{perconti2012}.

\subsection{Quantum IO Monad}
\label{sec:qio}

The Quantum IO (QIO) monad~\cite{qio} is a purely functional interface for quantum programming that provides a separation between the unitary (reversible) and non-unitary (irreversible) fragments of quantum computation. It provides isolation of quantum effects inside a monad similar to what we need to provide in our Quantum Hoare monad.

QIO interface was developed as a library for the Haskell programming language but its design was influenced~\cite{asg2010} by the category \textbf{FQC} of finite quantum computations (where computations are interpreted as superoperators) as explored by \citet{fqc06} in previous work. This is the most we will say about the relation of QIO monad to category theory in this paper.

Here we discuss the relevant concepts from the QIO interface. QIO provides a type for referring to qubits, \texttt{Qbit}; a type for unitary operations, \texttt{U}; and, the \texttt{QIO} type operator which is a monad indexed by the result of the quantum computation. The primitive quantum operations defined using the QIO monad below (Haskell syntax) are:

\begin{minipage}{0.95\linewidth}
\begin{lstlisting}[language=QHaskell]
mkQbit :: Bool -> QIO Qbit       -- initialization
applyU :: U -> QIO ()            -- apply a unitary to quantum state
measQbit :: Qbit -> QIO Bool     -- measurement
\end{lstlisting}
\end{minipage}

Further, \texttt{U} is defined as a monoid with neutral element, \texttt{mempty}, and operation, \texttt{mappend}, that encodes reversible operations on quantum state. The core unitary primitives that we will need are:

\begin{minipage}{0.95\linewidth}
\begin{lstlisting}[language=QHaskell]
rot :: Qbit -> ((Bool, Bool) -> C) -> U
cond :: Qbit -> (Bool -> U) -> U
\end{lstlisting}
\end{minipage}

\texttt{rot} takes a qubit and a two-by-two complex-valued unitary matrix (represented as a function from the matrix indices to $\mathbb{C}$) and lets one define arbitrary rotation on a single qubit. \texttt{rot} can then be used to define standard gates such as the Hadamard, H, and the Pauli gates, X, Y and Z. \texttt{cond} is the unitary conditional that is used to perform branching unitary operations. For the present paper, we use a simpler conditional, \texttt{ifQ}, that is defined as follows:

\begin{minipage}{0.95\linewidth}
\begin{lstlisting}[language=QHaskell]
ifQ :: Qbit -> U -> U
ifQ q u = cond q (\x -> if x then u else mempty)
\end{lstlisting}
\end{minipage}

That is, \texttt{ifQ} acts as the standard control operator in the quantum circuit model that runs its second argument based on the truth value of its first argument. Then, it is easy to define controlled gates such as CNOT with the expression $\kw{ifQ q1 (X q2)}$.

Quantum state in the QIO interface is modeled as a normalized vector that stores pairs representing complex amplitudes associated with each basis state (represented as a map from Qbit to Bool types). The operations defined over the vector class ensure that the quantum state is kept normalized throughout.

QIO further ensures that the monoidal structure of unitary operations lets one run a unitary operation over the complete quantum state. We elide details here and refer the reader to \cite{qio} for more.

%\subsection{Hoare Style Reasoning}
%\textit{Basics of Hoare-triples for non-specialists\ldots}
%
%\subsection{Program Proof and HTT}
%\textit{Basics of program proof and techniques for non-specialists\ldots}

\section{Quantum Hoare Type Theory}
\label{sec:qhtt}
In this section, we introduce the Quantum Hoare Type inspired by the QIO monad and its type theory (QHTT) by replacing the classical effectful portion of Hoare Type Theory with quantum effects. The core idea is to encapsulate any quantum effect inside a monadic Quantum Hoare type, $\Delta. \Psi .\{P\} x{ : }A \{Q\}$, and formalize reasoning of quantum effects using strongest postconditions in a similar fashion as HTT in the classical setting.

The next two sections discuss the syntax and typing of QHTT. The last section show examples written in QHTT.

\subsection{Syntax}
\label{sec:syntax}

\Cref{fig:syntax} shows the syntax of Quantum Hoare Type Theory. Our presentation closely follows that of HTT~\cite{nanevski_hoare_2008}.

%Complete grammar written using Ott tool at \url{https://github.com/k4rtik/QHT/blob/master/ott/qhtt.ott}.

\begin{figure}[ht]
	\begin{tabular}{lrcl}
		\textit{Types} & $A, B, C$ & ::= &
		\begin{minipage}[t]{0.45\columnwidth}%
			$ \type{1} \mid \type{Bool} \mid \type{Qbit} \mid A \otimes B \mid \Pi x{ : }A.B \mid \Delta. \Psi .\{P\} x{ : }A \{Q\}$
		\end{minipage}\\ \\
		\textit{Propositions} & $P, Q, R$ & ::= &
		\begin{minipage}[t]{0.5\columnwidth}%
			$ \top \mid \bot \mid P \wedge Q \mid P \vee Q \mid U \cdot P \mid \textbf{X} =_q \psi \mid \kw{uniform}(\textbf{X}) \mid \kw{separable}(\textbf{X}) \mid \kw{classical}(\textbf{X}) $
		\end{minipage}\\ \\
		% \textit{Q. Heaps} & $H, G$ & ::= & $ h \mid \kw{empty} \mid \kw{upd}(H, M, N) $\\ \\
		\textit{Elim terms} & $K, L$ & ::= & $ x \mid K N \mid N : A $\\
		\textit{Intro terms} & $N, O$ & ::= & $ K \mid () \mid \lambda x.N \mid \kw{do} E \mid \kw{true} \mid \kw{false} $\\ \\
		\textit{Q. Commands} & $c$ & ::= &
		\begin{minipage}[t]{0.5\columnwidth}%
			$ \kw{\textbf{init}} N \mid \kw{\textbf{apply}} U \kw{\textbf{to}} N \mid \kw{\textbf{meas}} N$
		\end{minipage}\\
		\textit{Computations} & $E, F$ & ::= & $ \kw{return} N \mid x \leftarrow K; E \mid x \Leftarrow c; E \mid x = N; E $\\ \\
%		\textit{Variable context} & $\Delta$ & ::= & $ \cdot \mid x : A, \Delta $ \\
%		\textit{Q. Heap context} & $\Psi$ & ::= & $ \cdot \mid h, \Psi$ \\
%		\textit{Proposition context} & $\Gamma$ & ::= & $ \cdot \mid P, \Gamma$ \\
		\textit{Unitaries} & $U$ & ::= & $ I \mid X \mid Y \mid Z \mid H \mid CX \mid CZ \mid S \mid T$
	\end{tabular}
	\Description{Syntax of Quantum Hoare Type Theory}
	\caption{Syntax of Quantum Hoare Type Theory}
	\label{fig:syntax}
\end{figure}

\paragraph{Types} There are primitive types for unit, booleans, and qubits. There are also type constructors for pairs, dependent functions and the Hoare type from HTT.

\paragraph{Propositions}
The predicate language is inspired by \citet{unruh2019} that follows subspace semantics. We need to be explicit about what we mean when we say that a certain state satisifes a certain predicate in the quantum setting. In this model, the propositions are subspaces of the Hilbert space corresponding to a quantum state. We use the metavariable \textbf{X} to refer to a list of quantum variables. Here are some examples:
\begin{itemize}
	\item $\top$ represents the complete Hilbert space that is always satisfied by any state.
	\item $\bot$ represents nothing, it is never satisfied.
	\item $P \wedge Q$ represent that both P and Q hold (conjunction), it is equivalent to the intersection of the subspaces.
	\item $P \vee Q$ similarly represents disjunction and is modeled as the sum (linear combination) of the subspaces P and Q.
	\item If a unitary operator U is applied to a state satisfying a proposition P, then the new proposition can be written as $U \cdot P$.
	\item If we want to write that a list of variables \textbf{X} is in a specific state, we can model that proposition as the variables being in the span of the state and use the notation, $\textbf{X} =_q \psi$.
\end{itemize}

Here are some examples. The postcondition of the program \texttt{qplus} below can be written as $r =_q \ket{+}$. The postcondition for the program \texttt{bell00} as $(a, b) =_q \frac{1}{\sqrt{2}}\ket{00}+\frac{1}{\sqrt{2}}\ket{11}$ or equivalently as $(a, b) =_q \ket{\Phi^+}$.

There are other propositions that involve ghosts:
\begin{itemize}
	\item uniform(\textbf{X}) is an abbreviation for $(\textbf{X}, \textbf{e}) = \frac{1}{\sqrt{2}}(\ket{00}+\ket{11})$ where \textbf{e} is  a fresh entangled ghost variable. It means that X is uniformly distributed.
	\item separable(\textbf{X}) is an abbreviation for $\textbf{X} \equiv_{q} \textbf{u}$ where \textbf{u} is a fresh unentangled ghost variable.
	\item class(\textbf{X}) is an abbreviation for $\textbf{X} \equiv_{cl} \textbf{u}$ where \textbf{u} is a fresh unentangled ghost variable. The classical equality symbol means that the variables on both side will measure to be the exact same value. That is, there is no superposition involved.
\end{itemize}

In addition to these quantum-specific propositions, the system also supports first-order logic (not shown) for reasoning about the pure fragment of the language.

\paragraph{Quantum State}

We use the terms quantum state and quantum heaps interchangeably throughout. A quantum heap is a partial function from qubits (that can in turn be thought of as locations, represented using natural numbers) to at most one quantum state vector.

% For the purpose of the type theory, heaps are functional, so that, for example, $\kw{upd}(H, M, N)$ returns a new heap after updating heap $H$ at location $M$ with $N$.

\paragraph{Terms}
The terms are divided into introduction and elimination sorts for the purpose of bidirectional typechecking like in HTT.

The pure fragment allows higher-order functions while the impure (effectful) fragment is encapsulated within the monadic \texttt{do} $E$ construct and supports a simple imperative quantum language inspired by QIO constructs. It is worth noting that \texttt{do} $E$ represents suspended computation and is considered pure.

\paragraph{Quantum Commands}
These are the quantum-specific effectful commands inspired by QIO for initialization, unitary application and measurement of qubits.
\texttt{init} $N$ initializes a given variable based on the value of the expression $N$ (typically \ket{0} or \ket{1} if N is a boolean).
\texttt{apply} $U$ \texttt{to} $X$ applies unitary operation $U$ to variables $X$.
\texttt{meas} $x$ measures the variable $x$ in the computational basis.
%\texttt{if y then E else F} executes computation $E$ if measuring variable $y$ returns 1 else executes $F$.

\paragraph{Computations} The computations are the usual monadic return and three sequencing operations that bind their result to a variable similar to HTT. The first, $x \leftarrow K$, executes a suspended computation (such as applying a function that includes a \texttt{do} $E$ in its body); the second, $x \Leftarrow c$ executes a primitive command $c$; and the last, $x = N$, is just syntactic sugar for let-binding.

\paragraph{Contexts} Contexts are modelled exactly the same way as in HTT. The only difference is that instead of classical heaps, we have quantum heaps.

\subsection{Typing Rules}
\label{sec:typing}

In this section, we provide some details about type checking in HTT and how it is different in the quantum case.

\subsubsection{Judgments}
We explain the main judgments used in HTT that are required to understand the typing rules in the next section. The type system is designed to be bidirectional and syntax directed and hence includes separate judgements for intro and elim terms. We are able to use them unchanged for QHTT. A recent survey by \citet{dunfield2019bidirectional} provides accessible introduction to bidirectional typing.

The type checking process also involves generating canonical forms for each term. A canonical form in HTT means a beta-normal (containing no beta-redexes) and eta-long (all intro terms are eta-expanded) form. We elide much detail here.

As usual, elim terms synthesize types ($\syn$) and intro terms are checked against the given type ($\chk$). Canonical forms are always synthesized. For the pure fragment:

\begin{center}
	\begin{tabular}{ll}
		$\Delta \vdash K \syn A [N']$ & Elim term K has type A and canonical form $N'$ \\
		$\Delta \vdash N \chk A [N']$ & Intro term N has type A and canonical form $N'$
	\end{tabular}
\end{center}

The judgments for computations involve synthesizing the strongest postconditions and checking whether a given postcondition applies:

\begin{center}
	\begin{tabular}{ll}
		$\Delta; P \vdash E \syn x:A.Q[E']$ & Computation E with precondition P has \textit{strongest} postcondition Q\\ & and returns value x of type A. Its canonical form is $E'$. \\
		$\Delta; P \vdash E \chk x:A.Q[E']$ & Computation E with precondition P has postcondition Q\\ & and returns value x of type A. Its canonical form is $E'$.
	\end{tabular}
\end{center}

Even though, we have shown the full forms of these judgments above, we will omit the canonical forms while presenting typing rules in the next section as they crowd the rules and do not affect the insight to be gained from them.

Finally, the judgement $\Delta; \Psi; \Gamma_1 \prove \Gamma_2$ encodes the sequent calculus for the predicate logic. Recall that $\Delta$, $\Psi$, and $\Gamma$ denote the variable context, the quantum heap context and the proposition context, respectively.

The type system includes rules for primitive effectful commands and those for structuring composition such as monadic unit and bind. We reuse most of the HTT rules except those for primitives for quantum effects that need to specify the strongest postconditions for each primitive, we discuss that next.

\subsubsection{Strongest Postconditions}
Here we show the strongest postconditions for the primitive quantum commands of QHTT encoded in their typing rules. Given a quantum command for initialization, unitary application or measurement, its strongest postcondition is a proposition that most precisely captures the relationship between the initial state and the modified state after the execution. These rules along with the \texttt{consq} (consequent) rule of HTT (that ensures weakening of the given strongest postcondition to an arbitrary postcondition) work together to ensure composition of verification.

We need to use the relational composition connective from HTT ($P \circ Q$) that captures how heap evolves with computation. It basically reads: $Q$ holds of the current heap which is obtained after modification of a prior heap for which P holds.

We also use HTT's difference operator ($\multimap$) below that captures changes to only the interesting fragment of the heap without modifying the rest of the heap.

We can now state the typing rules:

\paragraph{Initialization}
$x \Leftarrow \kw{init} N; E$

\begin{mathpar}
	\inferrule
	{\Delta \vdash N \chk \type{Bool}
		\\ \Delta, x : \type{Qbit}; P \circ (x =_q \mathit{bool2ket}(N)) \vdash E \syn y:B . Q}
	{\Delta; P \vdash x \Leftarrow \kw{init} N; E \syn y:B. (\exists x:\type{Qbit}.Q)}
\end{mathpar}
where x is fresh.

Initialization can only be performed for a term $N$ that can be type checked as a \type{Bool}. Then, we look at the rest of the computation, $E$, in a context that adds $x$ of type \type{Qbit} under a precondition that extends the previous precondition, $P$, with the strongest postcondition for initialization, that is, the newly bound variable $x$ is equal to the \ket{0} or \ket{1}; this should synthesize the strongest postcondition (with respect to the expanded precondition in the context), $Q$, for $E$.

To avoid dangling variables, we need to existentially quantify $x$ in the postcondition, $Q$, of the conclusion.

\paragraph{Measurement}
$x \Leftarrow \kw{meas} N; E$

\begin{mathpar}
	\inferrule
	{\Delta \vdash N \chk \type{Qbit}
		\\ \Delta; \Psi; P \prove (N =_q -)
		\\ \Delta, x:\type{Bool}; P \circ ((N =_q -) \multimap \top) \vdash E \syn y:B . Q}
	{\Delta; P \vdash x \Leftarrow \kw{meas} N; E \syn y:B. (\exists x:\type{Bool}.Q)}
\end{mathpar}

The measurement rule can be read in a similar way as the previous rule. But in measurement, we need to additionally prove that the verification condition (written as a sequent), the precondition $P$ implies that the qubit $N$ is allocated, holds in the heap context $\Psi$. The strongest postcondition here is that the fragment of heap that only refers to location N becomes empty. \todo{TODO: need to introduce ghost variable for measurement}

As may be apparent, initialization and measurement are analogous to HTT's \texttt{alloc} and \texttt{dealloc} primitives. We are working out precise details for unitary application, but at a high-level, they involve ensuring that the given unitary term actually represents a unitary matrix and updating the quantum state with the result of unitary application. This involves incorporating the monoidal structure of unitaries into our theory (as is done in QIO). This step also involves generating verification conditions that cannot be checked during this first phase of typechecking. We are also looking at alternatives such as the recently proposed sum-over-paths action semantics by \citet{amy18}.

\subsection{Sample programs}
\label{sec:examples}

In this section, we show some simple examples from the QIO work~\cite{qio} translated in our language and annotated with their program specifications using their Quantum Hoare types. An observation is that translating the programs was a very simple process except for coming up with the right specifications for the programs. We provide some commentary on propositions specified for these programs.

At the end of this section, we show a sample verification using QHTT for Bell pair generation.

\subsubsection{Hello Quantum World}
\leavevmode

\begin{minipage}{0.95\linewidth}
\begin{lstlisting}[language=QHaskell]
hqw : {\top} r : Bool {\top /\ r = false}
    = do q <= init false;
         r = meas q;
         return r
\end{lstlisting}
\end{minipage}

In this trivial program where we initialize a new qubit with false and then immediately measure it, we assert that the result is false. The complete specification also implicitly says that the existing quantum state is not affected in any way as both the pre and postcondition include the $\top$ proposition.

Verification steps follow:

\begin{minipage}{0.95\linewidth}
\begin{lstlisting}[language=QHaskell]
hqw : {\top} r : Bool {\top /\ r = false}
         -- \top
    = do q <= init false;
         -- q =q |0\> /\ class(q)
         r = meas q;
         -- (q, e) =q |00\> /\ r = false -- could use a sugared version for measured
         return r
         -- r = false -- if no qubit left, should be able to switch to \top here
\end{lstlisting}
\end{minipage}

\subsubsection{Coin Toss}
\leavevmode

\begin{minipage}{0.95\linewidth}
\begin{lstlisting}[language=QHaskell]
rnd : {\top} r : Bool {\top}
    = do q <= init false;
         apply H to q;
         r = meas q;
         return r
\end{lstlisting}
\end{minipage}

In the case of quantum coin toss, the result can be either true or false, hence, we need not specify any special postcondition as type checking the result will be sufficient for correctness.

Verification steps follow:

\begin{minipage}{0.95\linewidth}
\begin{lstlisting}[language=QHaskell]
rnd : {\top} r : Bool {\top}
         -- \top
    = do q <= init false;
         -- q =q |0\> /\ class(q)
         apply H to q;
         -- q =q |+\> /\ uniform(q)
         r = meas q;
         -- (q, e) =q |++\> -- perhaps we should be able to say uniform(r)?
         return r
         -- r = false \/ r = true -- or left unspecified
\end{lstlisting}
\end{minipage}

\subsubsection{Testing Bell Pair}
\leavevmode

\begin{minipage}{0.95\linewidth}
\begin{lstlisting}[language=QHaskell]
testBell00 : {\top} (a, b) : (Bool o* Bool) {\top /\ a = b}
         = do qa <= init false;
              apply H to qa;
              qb <= init false;
              <= apply CNOT to (qa, qb);
              a = meas qa;
              b = meas qb;
              return (a, b)
\end{lstlisting}
\end{minipage}

Here, we are asserting that the returned booleans $a$ and $b$ hold the same value, which is what we expect from the first Bell state prepared in this program.

\paragraph{Verification}
We would like to describe how QHTT lets us verify the correctness of the above program based on the specification provided as the type of the function. For illustration, we show the propositions annotated as comments as we step through the \texttt{testBell00} program below. We have elided specific details about unitary application as they are still being worked out.
\newpage
\begin{lstlisting}[language=QHaskell]
testBell00 : {\top} (a, b) : (Bool o* Bool) {\top /\ a = b}
              -- \top
         = do qa <= init false;
              -- qa =q |0\>, class(qa)
              apply H to qa;
              -- qa =q |+\>, uniform(qa)
              qb <= init false;
              -- qa =q |+\>, uniform(qa), qb =q |0\>, class(qb)
              apply CNOT to (qa, qb);
              -- (qa, qb) =q |++\>  -- can use a weaker but more general `EPR' here
              -- /\ uniform(qa, qb) -- this won't apply then
              a = meas qa;
              --   (qa, e1) =q |00\>, (qb, e2) =q |00\>, a = false
              -- \/ (qa, e1) =q |11\>, (qb, e2) =q |11\>, a = true
              b = meas qb;
              --   (qa, e1) =q |00\>, (qb, e2) =q |00\>, a = false, b = false
              -- \/ (qa, e1) =q |11\>, (qb, e2) =q |11\>, a = true,  b = true
              return (a, b)
\end{lstlisting}

In the proposition P2, we show that only the portion of the quantum state referred to by the \texttt{apply} command is affected. Similarly, in P4 we see that only the relevant portion of the heap containing the control and target qubits used in the CNOT operation are affected. In this case, we also needed to combine the two qubit state as they are now entangled. The last proposition, P5, merely encodes the strongest postcondition for measurement for each of the two qubits.

Finally, the \texttt{consq} rule of HTT ensures that the proposition P5 leads to the specified postcondition in the type of the program.

We show some two more examples in the appendix for a modular version of Bell pair generation (\Cref{app:mbp}) that shows use of higher-order features of QHTT and another for teleportation protocol (\Cref{app:teleport}). Both of these involve specifying propositions over quantum state whose theory we still need to work out.

%\subsection{Soundness / Type Checking Algorithm}

\subsection{Entangle disentangle}
\todo{OPTIONAL:}

\begin{lstlisting}[language=QHaskell]
entangle-disentangle : {T} (a, b) : (Qbit o* Qbit) {a = b}
= do
    -- P0: T
    a <= init false;
    -- P1: a =q |0\>, class(a)
    b <= init false;
    -- P2: P1, b =q |0\>, class(b)
    apply H to a;
    -- P3: H_a.P2     =   a =q |+\>, b =q |0\>, uniform(a), class(b)
    apply CX to (a, b);
    -- P4: CX_ab.P3   =   (a, b) =q |++\>, uniform(a, b)
    apply CX to (a, b);
    -- P5: CX_ab.P4   =   (a =q |+\>, b =q |0\>) \/ (a =q |0\>, b =q |+\>)
    apply H to a;
    -- P6: H_a.P5     =   (a =q |0\>, b =q |0\>) \/ (a =q |+\>, b =q |+\>)
    return (a, b)
\end{lstlisting}

\section{Implementation}
We are implementing QHTT in the F* programming language.

One issue with the original formulation of Hoare Type Theory is that using Hoare triples does not directly lead to a verification condition generation algorithm. This results in requiring a complicated bidirectional typing system for implementation. If we use proposition transformers as demonstrated by the use of Dijkstra monads in F*, we can avoid these issues \cite{swamy2013verifying}.

The current steps for the implementation are:

\begin{itemize}
	\item Design a memory model for representing quantum state, along with elementary operations such as read, write, lookup, etc
	\item Expose a new Quantum effect in F* by using the Dijkstra Monads for Free technique \cite{dm4free2017}.
	\item Port our language to work well with F* syntax.
\end{itemize}

This will necessarily take us away from the bidirectional typing approach used in the previous section. But the end result for the user would be the same. Indeed, F* system is an evolution of the HTT approach that comes with inherent support for effects and automation using an SMT solver.

%\section{Evaluation}

%\subsection{More Examples}
%\textit{add at least one example with scaling knob}

%\subsection{Circuit-complexity Considerations}

\section{Related Work}
\label{sec:related}
%\textit{Objective of this section\ldots}

%\subsection{Quantum Languages and Types}
%\textit{A chronology of language developments wrt to usefulness of types\ldots}

\subsection{Verification of Quantum Programs}
Previous work, such as Proto-Quipper~\cite{ross_algebraic_2015,rios_categorical_2017} and \qwire~\cite{paykin_qwire:_2017,rand_qwire_2017,rand_formally_2018} utilize a linear type system and dependent types to enforce a small subset of semantic properties, such as the no-cloning restriction and whether a unitary gate is of the right dimension. These advances in quantum type systems, although helpful, still fall short in encoding and enforcing even more useful properties that one would like to be able to express for the purpose of verification.

Our approach builds upon previous work in reasoning about quantum programs such as Quantum Weakest Preconditions~\cite{dhondt_quantum_2006} and Quantum Hoare Logic~\cite{ying_floydhoare_2012} in the spirit of \citet{hoare_axiomatic_1969} and \citet{dijkstra_discipline_1976} but attempts to bring those reasoning techniques into the type system. The hope is that programmers will be able to encode some of the semantic properties that they expect of their programs as specifications in their code and type checking will ensure correctness of some of those properties. In the classical setting, Hoare Type Theory (HTT)~\cite{nanevski_hoare_2008} accomplishes exactly this goal. Our attempt is to merge these ideas for the quantum realm.

%\textit{Add from Mingsheng Ying's book, papers, etc.}

\section{Conclusion and Perspectives}
\label{sec:conclusion}
In this paper, we have described our ongoing work on Quantum Hoare Type Theory, which modifies HTT for quantum computing using ideas from the Quantum IO monad work. This approach has the potential to be a unified system for programming, specification, and reasoning about quantum programs. We need to overcome challenges such as compactly specifying properties of quantum state when dealing with more than a few qubits. We also need to maintain the syntax directed nature of HTT's bidirectional typechecking while incorporating quantum wire types.

There are several avenues of future work to explore:

\paragraph{Quantum Language} Our programming language currently does not support conditionals or any iterative or recursive constructs. We would like to add those in future.

\paragraph{Mechanization} There are multiple implementations of HTT in Coq such as Ynot~\cite{ynot2008}. We are similarly working on mechanizing QHTT in Coq for higher assurance of the usefulness and soundness of our theory. This will also enable us to extract verified circuits in a lower level quantum language such as OpenQASM for execution on real machines.

\paragraph{Quantum Predicate Logic} An obvious need is to come up with a predicate logic similar to Separation Logic~\cite{reynolds2002} for quantum computing so as to be able to reason about only the interesting portions of the quantum state while still ensuring correctness of non-local effects such as entanglement. Various Quantum Hoare Logics that exist~\cite{ying_floydhoare_2012} currently do not support frame rules that provide Separation Logic its power. The closest approach is that taken by \citet{unruh2019} that allows predicates on quantum state similar to what we would like in our setting, such as whether certain qubits are in classical state, or in uniform superposition, entangled or separable. We hope to incorporate these ideas in this work; this may require us to use a subspace semantics for the quantum state as shown in \citet{unruh2019}. We share preliminary work in that direction in the appendix below.

\paragraph{Linearity} Peter Selinger and collaborators have recently proposed a linear dependent typed version of Proto-Quipper (dubbed Proto-Quipper-D)~\cite{selinger2020,fu2020linear}. It is an interesting challenge to reconcile linearity in our theory based on their proposal.

\paragraph{Circuits as Arrows} Further, Proto-Quipper treats quantum circuits as first class citizens of the language. We would like to explore modifying our theory to treat Quantum Hoare types as arrows instead of as monads as was suggested by \citet{so-arrows}. It makes sense from the perspective of sequential composition as arrows can have an arbitrary number of input/outputs as opposed to monads.

\paragraph{Behavioural Types} Another venue for exploration is to incorporate more precise types that can distinguish between qubits in pure classical state vs. those in superposition vs. those in entanglement~\cite{JorrandPerdrix2009} such as those inspired by the various quantum resource theories or the Heisenberg representation of quantum mechanics~\cite{rand_type_2019,rssl20}. This may help us provide more specific postconditions that quantum programmers expect to hold true of their programs.

\paragraph{Classical Effects} Finally, it will be an interesting challenge to reconcile both classical and quantum effects together in a single grand unified theory for effects.

%\textit{Future work about using Proto-Quipper/\qwire as languages, then extraction into QASM and checking generated verification conditions.}

\begin{acks}
	I thank John Reppy, Robert Rand and the anonymous reviewers of QPL 2020 for their feedback on an earlier presentation of this work.

	This material is based upon work supported by
	EPiQC, an \grantsponsor{GS100000001}{NSF}{http://dx.doi.org/10.13039/100000001}
	Expedition in Computing, under Grant
	No.~\grantnum{GS100000001}{1730449}.  Any opinions, findings, and
	conclusions or recommendations expressed in this material are those
	of the authors and do not necessarily reflect the views of the
	National Science Foundation.
\end{acks}

\newpage

\bibliography{references}

\newpage

\newpage

\appendix

\section{Sample Proof}
Complete derivation tree for Hello Quantum World:

\begin{turn}{90}
	\begin{minipage}{42pc}
	\begin{mathpar}
		\inferrule*[right=HIntro]
		{\inferrule*[right=consq]
			{\inferrule*[right=init]
				{\inferrule*[right=measure]
					{\inferrule*[right=return]
						{q : \type{Qbit}, r : \type{Bool} \vdash r \chk \type{Bool}}
						{q : \type{Qbit}, r : \type{Bool}; P_1 \circ ((q \mapsto -) \multimap \top) \vdash \kw{return} r \syn r : \type{Bool} . R}
						\\ q : \type{Qbit} \vdash q \chk \type{Qbit}
						\\ \cdot; P_0 * (q \mapsto \ket{0}) \prove (q \hookrightarrow -)
					}
					{q : \type{Qbit}; P_0 * (q \mapsto \ket{0}) \vdash r \Leftarrow \kw{meas} q; E_3 \syn r : \type{Bool} . (\exists r : \type{Bool}.R)}
					\\ \cdot \vdash \kw{0} \chk \type{Bool}
				}
				{
					\cdot; P_0 \vdash q \Leftarrow \kw{init false}; E_{23} \syn r : \type{Bool} . (\exists q : \type{Qbit}.R)
				}
				\\ r : \type{Bool}; i,m ; R \prove \top \multimap \top \wedge Id(r, \kw{0})
			}
			{
				\cdot; \lambda i . \lambda m . i = m \wedge (\top * \lambda m' \top)m \vdash E_1; E_{23} \chk r : \type{Bool} . (\top \multimap \top \wedge Id(r, \kw{0}))
			}
		}
		{\cdot \vdash \kw{do} E \chk \{\top\} r : \type{Bool} \{\top \wedge \kw{Id}(r, \kw{0})\}}
	\end{mathpar}
	\end{minipage}
\end{turn}

\section{Modular Bell Pair}
\label{app:mbp}
Writing a modular version of \texttt{testBell}.

\subsection{Hadamard basis states}
\begin{lstlisting}[language=QHaskell]
qplus : {\top} r : Qbit {r =q |+\>}
      = do q <= init false;
           q <= apply H to q;
           return q

qminus : {\top} r : Qbit {r =q |-\>}
       = do q <= init true;
            q <= apply H to q;
            return q
\end{lstlisting}

\subsection{Creating entanglement}
\begin{lstlisting}[language=QHaskell]
share : \Pi a : Qbit.
        {a =q (alpha |0\> + beta |1\>)}
           (a, b) : (Qbit o* Qbit)
        {(a, b) =q (alpha |00\> + beta |11\>)}
      = \a.do b <= init false;
              (a, b) <= apply CNot to [a, b];
              return (a, b)
\end{lstlisting}

\subsection{Bell pair}
\begin{lstlisting}[language=QHaskell]
bell00 : {\top} (a, b) : (Qbit o* Qbit) {(a,b) =q |\Phi+\>}
     = do qa <- qplus;
          (qa, qb) <- share qa;
          return (qa, qb)
\end{lstlisting}

\subsection{Testing modular Bell pair}
\todo{TODO: how is classical equality ensured?}
\begin{lstlisting}[language=QHaskell]
testBell : {\top} (a, b) : (Bool o* Bool) {\top /\ a = b}
         = do (qa, qb) <- bell00;
              a <= meas qa;
              b <= meas qb;
              return (a, b)
\end{lstlisting}

\section{Teleportation}
\label{app:teleport}
\subsection{Alice's circuit}
\begin{lstlisting}[language=QHaskell]
alice : \Pi q : Qbit. \Pi a : Qbit
        {q =q (alpha |0\> + beta |1\>) /\ (a, e) =q |\Phi+\>}    -- a is entangled with ghost var e
           (m1, m2) : (Bool o* Bool)
        {  (m1, m2) = 00 /\ e =q (alpha |0\> + beta |1\>)
         \/ (m1, m2) = 01 /\ e =q (alpha |1\> + beta |0\>)
         \/ (m1, m2) = 10 /\ e =q (alpha |0\> - beta |1\>)
         \/ (m1, m2) = 11 /\ e =q (alpha |1\> - beta |0\>)}
      = \q.\a.do (q, a) <= apply CNOT to [q, a];
                 q <= apply H to q;
                 rq <= meas q;
                 ra <= meas a;
                 return (rq, ra)
\end{lstlisting}

\subsection{Bob's circuit}
\todo{TODO provide correct propositions using ghost e}
\begin{lstlisting}[language=QHaskell]
bob : \Pi m1 m2 : Bool. \Pi b : Qbit
      {(b, e) =q |\Phi+\>}
         r : Qbit
      {\top}
      = \m1.\m2.\b.do (m1, b) <= apply C_Z to [m1, b];
                      (m2, b) <= apply C_X to [m2, b];
                      return b
\end{lstlisting}

\subsection{Teleport}
\begin{lstlisting}[language=QHaskell]
teleport : \Pi q : Qbit.
           {q =q (alpha |0\> + beta |1\>)}
              b : Qbit
           {r =q (alpha |0\> + beta |1\>)}
         = \q.do (a, b) <- bell00;
                 (m1, m2) <- alice q a;
                 b <- bob m1 m2 b;
                 return b
\end{lstlisting}

\section{Ideas from Unruh 2019}
\subsection{Model of the Quantum State}
A program starts with a fixed but unknown number of qubits. For simplicity, assume they are countably infinite.
With access to commands for initialization, the program can allocate as many qubits as it needs.
In our model of the quantum state, the qubits are divided into a few categories: those that are being used (ie, that have been allocated) by the program (program variables), denoted by X; those that are ghosts (only used in the logic, but not available to the program), denoted by G and the rest that are unallocated. The ghost qubits are then further categorized into entangled (E) and unentangled (U), which mean exactly what they are called.

All of these variables draw values from classical sets of values such as {0, 1}, that can be considered as their type. For operations such as substitution, it is important that the types match. At this point, we should make it clear that we are not limited to treating a single variable as a single qubit anymore; a variable can represent many qubits together, for example, if the type of the variable is {0, 1, 2, 3}, it necessarily requires at least two qubits to store these classical values.

Now, the pure quantum state accessible to the program can be considered as the superposition (linear combination) of all of the basis vectors that span the Hilbert space corresponding to the given qubits.

We will also need to talk about mixed states as we deal with measurements that can result in probabilistic outcomes. We represent mixed states using density operators, $\rho = \Sigma_i p_i \mathrm{proj}(\psi_i)$, where $p_i$ represents the probability of the state being $\psi_i$.

Applying unitaries to the quantum state is same as before, in that, we apply the operation to the specified variables and identity to all other program variables.

%What is the relation between the program variables and the subspaces corresponding to the predicates that we are talking about? We need to define the notion of free variables for a predicate $A$. fv(A) consists of those variables that solely describe the predicate A.

\subsection{Improvements to the quantum commands}

Added if then else and a simpler form of apply; and the syntactic sugar for quantum and classical assignments in the ott document.

\subsection{Predicates with Ghosts}
\todo{To Do: consider adding distrib}

Added uniform, separable and classical in the ott document. distrib seems too general for our needs.

\subsection{Rules of the Hoare logic}

Core rules:

\todo{To Do: total 11 core rules: 6 for the language primitives, 5 structural. Out of which two are for case distinction and the remaining three deal with ghosts}

Derived rules:

\todo{To Do: conseq and others as needed}

\subsection{Implementation Options}

The semantics considered in this work uses abstract linear algebra without depending on a concrete representation (such as on matrices) but current library support for such abstract linear algebra (such as vector spaces and subspaces) in dependent type theoretic systems such as Coq seems limited.

I found Georges Gonthiers' ITP 2011 paper ``Point-Free, Set-Free Concrete Linear Algebra'' (\url{https://hal.inria.fr/hal-00805966/document}) that models abstract linear algebra using matrices but still exposes a point-free interface to vector spaces still in line with our needs. The implementation seems to be what is now the mathcomp.algebra.vector library (\url{https://math-comp.github.io/htmldoc/mathcomp.algebra.vector.html}). There are couple of concerns:

\begin{itemize}
	\item this library is limited to finite dimensional vector spaces which is probably okay for our needs but not the same as the infinite dimension semantics presented in Unruh's work.
	\item since it is still dependent on a concrete matrix representation, it does not give us complete flexibility in renamings of the quantum variables under consideration. I need to investigate this further.
	\item It's unclear to me how production-ready this library might be as I could not find examples of it being used in a project. The couple of Coq workshops that I found stop at the matrix algebra library (\url{https://math-comp.github.io/htmldoc/mathcomp.algebra.mxalgebra.html}).
\end{itemize}

None of these seem completely impossible to overcome for our needs, but we may run into hiccups here and there.

Lean seems to have a better support for linear algebra (\url{https://leanprover-community.github.io/mathlib-overview.html}) but it may require significantly more work to understand that system.

Robert suggests another approach that is to limit the expressiveness of the system and implement the limited logic proposed in Hner, Hoefler and Troyer's ``Using Hoare logic for quantum circuit optimization'' (\url{https://arxiv.org/abs/1810.00375}), an improved version of which is going to be presented at OOPSLA in November. This may even be possible in F* with some effort.

\subsection{Remarks}
Now, the question is whether we can use this memory model (based on subspace semantics), predicate logic and rules and still continue to use bidirectional typing for the type system? If so, it's probably worth finishing up the rule for unitary application using this memory model.

The implementation notes suggest that switching to F* seems to require making too many changes, both in the syntax of the language and in the core theory; which is something probably best left for a future implementation project.

%\section{Sample Proof}
%\textit{Coq code / Annotated proof objects from implementation\ldots}

\end{document}
