\documentclass[acmsmall,nonacm,timestamp,review=false,anonymous=false]{acmart}

\acmJournal{PACMPL}

\bibliographystyle{ACM-Reference-Format}
\citestyle{acmauthoryear}

\usepackage[braket]{qcircuit}
\usepackage{mathpartir}
\usepackage{mathtools}
\usepackage{xspace}
\usepackage{cleveref}
\crefformat{section}{\S#2#1#3}

\definecolor{dkgreen}{rgb}{0,0.35,0}

\usepackage{listings}
\lstloadlanguages{Haskell}
\lstdefinelanguage{QHaskell}{
	language     = Haskell,
	morekeywords = {Qbit, U, C, Pure},
}

\lstset{
	basicstyle=\small\ttfamily,
	flexiblecolumns=false,
	basewidth={0.5em,0.45em},
	commentstyle=\color{dkgreen},
	keywordstyle=\bfseries\color{blue},
	stringstyle=\color{violet},
	literate={+}{{$+$}}1 {/}{{$/$}}1 {*}{{$*$}}1 {=}{{$=$}}1
	{>}{{$>$}}1 {<}{{$<$}}1 {\\}{{$\lambda$}}1
	{\\\\}{{\char`\\\char`\\}}1
	{->}{{$\rightarrow$}}2 {>=}{{$\geq$}}2 {<-}{{$\leftarrow$}}2
	{<=}{{$\Leftarrow$}}2 {=>}{{$\Rightarrow$}}2
	{\ .}{{$\circ$}}2 {\ .\ }{{$\circ$}}2
	{>>}{{>>}}2 {>>=}{{>>=}}2
	{|}{{$\vert$}}1 {\\>}{{$\rangle$}}1
	{/\\}{{$\wedge$}}1 {\\/}{{$\vee$}}1
	{\\in}{{$\in$}}1 {\\o}{{$\circ$}}1 {\\Pi}{{$\Pi$}}1
	{\\Phi+}{{$\Phi^+$}}2
	{|->}{{$\mapsto$}}2 {-o}{{$\multimap$}}2
}

\newcommand{\sqir}{\ensuremath{s\textsc{qir}}\xspace}
\newcommand{\qwire}{\ensuremath{\mathcal{Q}\textsc{wire}}\xspace}
\newcommand{\denote}[1]{\llbracket #1 \rrbracket\xspace}
\newcommand{\qdenote}[1]{(\!| #1 |\!)\xspace}

\newcommand{\type}[1]{\textrm{\textbf{#1}}}
\newcommand{\kw}[1]{\,\mathrm{\texttt{#1}}\,}
\newcommand{\todo}[1]{\textcolor{red}{#1}}

% modified from bidir-survey
\definecolor{dRed}{rgb}{0.85, 0.0, 0.0}
\definecolor{dBlue}{rgb}{0.0, 0.0, 0.85}

\newcommand{\chkcolor}{dBlue}
\newcommand{\syncolor}{dRed}
\newcommand{\chk}{\,\textcolor{\chkcolor}{{\stackrel{\leftarrow}{\in}}}\,}
\newcommand{\uncoloredsyn}{{{\stackrel{\rightarrow}{\in}}}}
\newcommand{\syn}{\,\textcolor{\syncolor}{\uncoloredsyn}\,}

\newcommand{\prove}{\models}

\title{Quantum Hoare Type Theory}
\subtitle{Master's Paper}

\author{Kartik Singhal}
\orcid{0000-0003-1132-269X}
\affiliation{
	\position{PhD Student}
	\department{Department of Computer Science}
	\institution{University of Chicago}
	\city{Chicago}
	\state{IL}
%	\postcode{60637}
	\country{USA}}
\email{ks@cs.uchicago.edu}

\authornote{Homepage: \url{http://ks.cs.uchicago.edu}}

%\authorsaddresses{}

\begin{document}

\begin{abstract}
	% Foreward
	%Context and Need
	As quantum computers become real, it is high time we come up with effective techniques that help programmers write correct quantum programs.
	%Need
	In classical computing, formal verification and sound static type systems prevent several classes of bugs from being introduced. There is a need for similar techniques in the quantum regime.
	%Task
	Inspired by Hoare Type Theory in the classical paradigm, we propose Quantum Hoare Types by extending the Quantum IO Monad by indexing it with pre- and post-conditions that serve as program specifications.
	%Object
	In this paper, we introduce Quantum Hoare Type Theory (QHTT), present its syntax and typing rules, and demonstrate its effectiveness with the help of examples.
	% Summary
	%Findings

	%Conclusion
	QHTT has the potential to be a unified system for programming, specifying, and reasoning about quantum programs.
	%Perspectives
%	This is a work in progress.
%Quantum Computing is a new and upcoming way to utilize quantum mechanics for computation. It is easy to introduce bugs while programming quantum computers similar to classical computing. Strong static type systems have prevented a lot of bugs from being introduced in the classical paradigm. There is a similar need for well-designed static types in the domain of quantum computing. We propose Quantum Hoare Types that let programmers reason statically about certain semantic properties of their quantum programs and further allow a limited form of formal verification.
\end{abstract}

\maketitle

\tableofcontents

%\listoffigures

%\newpage

\section{Introduction}
It is difficult to reason about the correctness of quantum programs. Sound static type systems help prevent a huge class of bugs from occurring but since the realm of quantum programming is still new there is not a lot of consensus on what kind of types make the most sense. Further, it is unclear how much they help programmers reason about the semantic properties associated with the quantum algorithms that they are implementing.

Recent work~\cite{huang_qdb:_2018,huang_statistical_2019} as part of EPiQC\footnote{EPiQC: Enabling Practical-Scale Quantum Computation:  \url{https://epiqc.cs.uchicago.edu}} has identified several classes of bugs in quantum programs and proposed approaches to tackle them. The technique that holds the most promise is assertion checking using preconditions and postconditions. But assertions are usually checked dynamically during runtime, which can be wasteful of precious quantum computing or simulation resources.

As programming languages researchers, we think it will be better to encode such assertions into a static type system both for formal verification and to aid the programmers in writing correct programs from the start. Inspired by the use of Hoare triples in the verification of imperative programs and building on the idea of Hoare Type Theory (HTT) for classical programming languages~\cite{nanevski_hoare_2008}, we extend the Quantum IO Monad interface~\cite{qio} and propose Quantum Hoare Type Theory aimed at enabling both sound static type checking and formal verification of quantum programs.

The main idea is that instead of just indexing the QIO monad type with the type of computation result, we can also index it with pre-conditions and post-conditions so as to integrate Hoare-style reasoning into the type system itself. The resulting Quantum Hoare Type, $\{P\}\ x{ : }A\ \{Q\}$, specifies the preconditions, $P$, that hold on the quantum state before execution; the result, $x$, and its type, $A$; and, the postconditions, $Q$, that are true for the quantum state after successful execution. In this way the effectful quantum fragment of the program is effectively encapsulated inside the Quantum Hoare monad. Our theory, like HTT, allows the usual equational reasoning for the pure classical fragments of the program and uses syntax-directed type checking for generating strongest postconditions for the quantum fragment.

This paper is organized as follows. We discuss background in the next section, \cref{sec:bg}; specifically, quantum computing (\cref{sec:qc}),  Hoare Type Theory in the classical setting (\cref{sec:htt}) and then the Quantum IO Monad interface (\cref{sec:qio}). Then we introduce our contributions in merging these ideas together for specification and enforcement of useful semantic properties in section~\cref{sec:qhtt} along with its syntax (\cref{sec:syntax}), typing rules (\cref{sec:typing}) and, some examples (\cref{sec:examples}). Some related work follows in \cref{sec:related}. Finally, we conclude and share ideas for future work in the final section (\cref{sec:conclusion}).

\section{Background}
\label{sec:bg}
In this section, we provide background on the core ideas from existing literature that form the foundation for our work --- Hoare Type Theory (HTT) and the Quantum IO Monad interface. We start with some basics of quantum computing.
% and refer the reader to Nielsen's excellent series of essays~\cite{matuschak2019} for a first introduction and to the standard textbook~\cite{nielsen2010} for advanced material.

\subsection{Quantum Computing}
\label{sec:qc}
The basic unit of information in quantum computing is a qubit, that can be represented using a unit vector in a two-dimensional complex vector space. Using Dirac's bra-ket notation, we can write an arbitrary qubit, $\ket{\psi}$, as a linear combination of the computational basis vectors: $\ket{\psi} = \alpha\ket{0} + \beta\ket{1}$, where $\ket{0}=\begin{bsmallmatrix}
1 \\
0
\end{bsmallmatrix}$ and $\ket{1}=\begin{bsmallmatrix}
0 \\
1
\end{bsmallmatrix}$, and the two constants are complex amplitudes that are normalized using the constraint $|\alpha|^2 +|\beta|^2 = 1$. This means that when measured, the probability of the qubit being in the state 0 is $|\alpha|^2$ and that for the state 1 is $|\beta|^2$. To work with multiple qubits, we need to take their tensor product, denoted by $\otimes$. Computation is performed by the application of unitary quantum gates, such as the Hadamard (H) gate or the controlled NOT (CX) gate, that can be represented as square matrices. Mathematically, a gate application is equivalent to multiplying the matrix representing the gate with the state vector of the qubit(s).

This basic unit of information is not the only reason why quantum computing is fundamentally different from classical computing---certain quantum mechanical phenomenon are highly counterintuitive! One such phenomenon is \textit{quantum entanglement} which, at its most basic level, involves a correlation between two qubits such that when one is measured, the outcome obtained necessarily influences the measurement outcome of the other qubit (even if the two qubits are far apart). %We will see how this property can be utilized for computation in the quantum teleportation algorithm that we describe and program in \S\ref{telep}.
We refer the reader to the standard textbook by \citet{nielsen_quantum_2010} or the excellent series of essays by \citet{matuschak2019} for more background.

\subsection{Hoare Type Theory}
\label{sec:htt}
A Hoare type, $\Delta.\Psi.\{P\}\; \texttt{x}:A\; \{Q\}$, encodes preconditions and postconditions in the same spirit as Hoare triples to allow both specification and verification of effectful classical programs. It can be read as `for a stateful computation executed in a heap that satisfies precondition $P$, return a value of type $A$ in a heap that satisfies postcondition $Q$.' The contexts, $\Delta$ and $\Psi$, contain the variables and heap variables that may appear in both $P$ and $Q$. In this presentation, we will omit the contexts in the Hoare type when they are unneeded. We show an example to demonstrate the expressiveness of a Hoare type --- the \texttt{alloc} primitive from HTT~\cite{nanevski_hoare_2008}:
\begin{mathpar}
	\texttt{alloc} : \forall \alpha. \Pi x:\alpha. \{\texttt{emp}\}\; y:\texttt{nat}\; \{y \mapsto_{\alpha} x\}
\end{mathpar}

This type specifies that \texttt{alloc} is a polymorphic function that takes as input a variable, $x$, of any simple type, $\alpha$, that is executed in an empty heap (meaning it does not affect existing heap), returns a new location bound by a fresh variable, $y$, of type \texttt{nat} and initializes it with the supplied value $x$ of type $\alpha$.

Type checking in HTT involves generation of strongest postconditions at each step of the program. Verification is a two-step process: the first phase does basic type checking and verification condition generation which is decidable, the second phase needs to show the validity of the generated verification conditions, which can be undecidable. This second phase can be deferred to an automated theorem prover.

We provide more details when we introduce QHTT in section~\cref{sec:qhtt}. An accessible introduction to Hoare Type Theory is available in the lecture notes by \citet{perconti2012}.

\subsection{Quantum IO Monad}
\label{sec:qio}

The Quantum IO (QIO) monad~\cite{qio} is a purely functional interface for quantum programming that provides a separation between the unitary (reversible) and non-unitary (irreversible) fragments of quantum computation. It provides isolation of quantum effects inside a monad similar to what we need to provide in our Quantum Hoare monad.

QIO interface was developed as a library for the Haskell programming language but its design was influenced~\cite{asg2010} by the category \textbf{FQC} of finite quantum computations (where computations are interpreted as superoperators) as explored by \citet{fqc06} in previous work. This is the most we will say about the relation of QIO monad to category theory in this paper.

Here we discuss the relevant bits from the QIO interface. QIO provides a type for referring to qubits, \texttt{Qbit}; a type for unitary operations, \texttt{U}; and, the \texttt{QIO} type operator which is a monad indexed by the result of the quantum computation. The primitive quantum operations defined using the QIO monad below (Haskell syntax) are:

\begin{minipage}{0.95\linewidth}
\begin{lstlisting}[language=QHaskell]
mkQbit :: Bool -> QIO Qbit       -- initialization
applyU :: U -> QIO ()            -- apply a unitary to quantum state
measQbit :: Qbit -> QIO Bool     -- measurement
\end{lstlisting}
\end{minipage}

Further, \texttt{U} is defined as a monoid with neutral element, \texttt{mempty}, and operation, \texttt{mappend}, that encodes reversible operations on quantum state. The core unitary primitives that we will need are:

\begin{minipage}{0.95\linewidth}
\begin{lstlisting}[language=QHaskell]
rot :: Qbit -> ((Bool, Bool) -> C) -> U
cond :: Qbit -> (Bool -> U) -> U
\end{lstlisting}
\end{minipage}

\texttt{rot} takes a qubit and a two-by-two complex-valued unitary matrix (represented as a function from the matrix indices to $\mathbb{C}$) and lets one define arbitrary rotation on a single qubit. \texttt{rot} can then be used to define standard gates such as the Hadamard, H, and the Pauli gates, X, Y and Z. \texttt{cond} is the unitary conditional that is used to perform branching unitary operations. For the present paper, we use a simpler conditional, \texttt{ifQ}, that is defined as follows:

\begin{minipage}{0.95\linewidth}
\begin{lstlisting}[language=QHaskell]
ifQ :: Qbit -> U -> U
ifQ q u = cond q (\x -> if x then u else mempty)
\end{lstlisting}
\end{minipage}

That is, \texttt{ifQ} acts as the standard control operator in the quantum circuit model that runs its second argument based on the truth value of its first argument. Then, it is easy to define controlled gates such as CNOT with the expression $\kw{ifQ q1 (X q2)}$.

Quantum state in the QIO interface is modeled as a normalized vector that stores pairs representing complex amplitudes associated with each basis state (represented as a map from Qbit to Bool types). The operations defined over the vector class ensure that the quantum state is kept normalized throughout.

QIO further ensures that the monoidal structure of unitary operations lets one run a unitary operation over the complete quantum state. We elide details here and refer the reader to \cite{qio} for more.

%\subsection{Hoare Style Reasoning}
%\textit{Basics of Hoare-triples for non-specialists\ldots}
%
%\subsection{Program Proof and HTT}
%\textit{Basics of program proof and techniques for non-specialists\ldots}

\section{Quantum Hoare Type Theory}
\label{sec:qhtt}
In this section, we introduce the Quantum Hoare Type inspired by the QIO monad and its type theory (QHTT) by replacing the classical effectful portion of Hoare Type Theory with quantum effects. The core idea is to encapsulate any quantum effect inside a monadic Quantum Hoare type, $\Delta. \Psi .\{P\} x{ : }A \{Q\}$, and formalize reasoning of quantum effects using strongest postconditions in a similar fashion as HTT in the classical setting.

The next two sections discuss the syntax and typing of QHTT. The last section show examples written in QHTT.

\subsection{Syntax}
\label{sec:syntax}

\Cref{fig:syntax} shows the syntax of Quantum Hoare Type Theory. Our presentation closely follows that of HTT~\cite{nanevski_hoare_2008}.

Complete grammar written using Ott tool at \url{https://github.com/k4rtik/QHT/blob/master/ott/qhtt.ott}.

\begin{figure}[ht]
	\begin{tabular}{lrcl}
		\textit{Types} & $A, B, C$ & ::= &
		\begin{minipage}[t]{0.45\columnwidth}%
			$ \type{1} \mid \type{Bool} \mid \type{Qbit} \mid \type{U} \mid \type{Pure} \mid A \otimes B \mid \Pi x{ : }A.B \mid \Delta. \Psi .\{P\} x{ : }A \{Q\}$
		\end{minipage}\\ \\
		\textit{Assertions} & $P, Q, R$ & ::= &
		\begin{minipage}[t]{0.45\columnwidth}%
			$ \top \mid \bot \mid P \wedge Q \mid P \vee Q \mid P \supset Q \mid \neg P \mid \exists x{:}A.P \mid \forall x{:}A.P \mid \exists h{:}\kw{heap}.P \mid \forall h{:}\kw{heap}.P \mid \kw{Id}_A(M, N) \mid \kw{HId}(H, G) \mid \kw{indom}(H,M) $
		\end{minipage}\\ \\
		\textit{Q. Heaps} & $H, G$ & ::= & $ h \mid \kw{empty} \mid \kw{upd}(H, M, N) $\\ \\
		\textit{Elim terms} & $K, L$ & ::= & $ x \mid K M \mid M : A $\\
		\textit{Intro terms} & $M, N, O$ & ::= & $ K \mid () \mid \lambda x.M \mid \kw{do} E \mid \kw{true} \mid \kw{false} $\\ \\
		\textit{Q. Commands} & $c$ & ::= &
		\begin{minipage}[t]{0.45\columnwidth}%
			$ \kw{mkQbit} M \mid \kw{measQbit} M \mid \kw{applyU} M$
		\end{minipage}\\
		\textit{Computations} & $E, F$ & ::= & $ \kw{return} M \mid x \leftarrow K; E \mid x \Leftarrow c; E \mid x =_A M; E $\\ \\
		\textit{Variable context} & $\Delta$ & ::= & $ \cdot \mid x : A, \Delta $ \\
		\textit{Q. Heap context} & $\Psi$ & ::= & $ \cdot \mid h, \Psi$ \\
		\textit{Assertion context} & $\Gamma$ & ::= & $ \cdot \mid P, \Gamma$ \\
	\end{tabular}
	\Description{Syntax of Quantum Hoare Type Theory}
	\caption{Syntax of Quantum Hoare Type Theory}
	\label{fig:syntax}
\end{figure}

\paragraph{Types} We include primitive types for unit, booleans, qubits and unitary operations, and a type \type{Pure} for representing pure quantum state vectors (complex valued vectors in Hilbert space); these correspond to similar types in the QIO work. There are also type constructors for pairs, dependent functions and the Hoare type from HTT.

\paragraph{Assertions}
Apart from the usual first order logic, we have assertions for reasoning about propositional equality of terms, $\kw{Id}_A(M, N)$, and heaps, $\kw{HId}(H, G)$.

As done in HTT, some common convenience assertions can be defined using the base primitives. Particularly, $\kw{emp}$ denotes that the current heap, say $h$, is empty, that is, $\kw{HId}(h, \kw{empty})$. $M \mapsto N$ represents the only mapping in the (singleton) heap. $M \hookrightarrow N$ says that looking up $M$ in the heap returns $N$ which can be more explicitly written as $\kw{seleq}(H, M, N)$.

\paragraph{Quantum State}

We use the terms quantum state and quantum heaps interchangeably throughout. A quantum heap is a partial function from qubits (that can in turn be thought of as locations, represented using natural numbers) to at most one quantum state vector.

For the purpose of the type theory, heaps are functional, so that, for example, $\kw{upd}(H, M, N)$ returns a new heap after updating heap $H$ at location $M$ with $N$.

\paragraph{Terms}
The terms are divided into introduction and elimination sorts for the purpose of bidirectional typechecking like in HTT.

The pure fragment allows higher-order functions while the impure (effectful) fragment is encapsulated within the monadic \texttt{do} $E$ construct and supports a simple imperative quantum language inspired by QIO constructs. It is worth noting that \texttt{do} $E$ represents suspended computation and is considered pure.

\paragraph{Quantum Commands}
These are the quantum-specific effectful commands from QIO for initialization, unitary application and measurement of qubits.

\paragraph{Computations} The computations are the usual monadic return and three sequencing operations that bind their result to a variable similar to HTT. The first, $x \leftarrow K$, executes a suspended computation (such as applying a function that includes a \texttt{do} $E$ in its body); the second, $x \Leftarrow c$ executes a primitive command $c$; and the last, $x =_A M$, is just syntactic sugar for let-binding.

\paragraph{Contexts} Contexts are modelled exactly the same way as in HTT. The only difference is that instead of classical heaps, we have quantum heaps.

\subsection{Typing Rules}
\label{sec:typing}

In this section, we provide some details about type checking in HTT and how it is different in the quantum case.

\subsubsection{Judgments}
We explain the main judgments used in HTT that are required to understand the typing rules in the next section. The type system is designed to be bidirectional and syntax directed and hence includes separate judgements for intro and elim terms. We are able to use them unchanged for QHTT. A recent survey by \citet{dunfield2019bidirectional} provides accessible introduction to bidirectional typing.

The type checking process also involves generating canonical forms for each term. A canonical form in HTT means a beta-normal (containing no beta-redexes) and eta-long (all intro terms are eta-expanded) form. We elide much detail here.

As usual, elim terms synthesize types ($\syn$) and intro terms are checked against the given type ($\chk$). Canonical forms are always synthesized. For the pure fragment:

\begin{center}
	\begin{tabular}{ll}
		$\Delta \vdash K \syn A [N']$ & Elim term K has type A and canonical form $N'$ \\
		$\Delta \vdash M \chk A [M']$ & Intro term M has type A and canonical form $M'$
	\end{tabular}
\end{center}

The judgments for computations involve synthesizing the strongest postconditions and checking whether a given postcondition applies:

\begin{center}
	\begin{tabular}{ll}
		$\Delta; P \vdash E \syn x:A.Q[E']$ & Computation E with precondition P has \textit{strongest} postcondition Q\\ & and returns value x of type A. Its canonical form is $E'$. \\
		$\Delta; P \vdash E \chk x:A.Q[E']$ & Computation E with precondition P has postcondition Q\\ & and returns value x of type A. Its canonical form is $E'$.
	\end{tabular}
\end{center}

Even though, we have shown the full forms of these judgments above, we will omit the canonical forms while presenting typing rules in the next section as they crowd the rules and do not affect the insight to be gained from them.

Finally, the judgement $\Delta; \Psi; \Gamma_1 \prove \Gamma_2$ encodes the sequent calculus for the assertion logic. Recall that $\Delta$, $\Psi$, and $\Gamma$ denote the variable context, the quantum heap context and the assertion context, respectively.

The type system includes rules for primitive effectful commands and those for structuring composition such as monadic unit and bind. We reuse most of the HTT rules except those for primitives for quantum effects that need to specify the strongest postconditions for each primitive, we discuss that next.

\subsubsection{Strongest Postconditions}
Here we show the strongest postconditions for the primitive quantum commands of QHTT encoded in their typing rules. Given a quantum command for initialization, unitary application or measurement, its strongest postcondition is an assertion that most precisely captures the relationship between the initial state and the modified state after the execution. These rules along with the \texttt{consq} (consequent) rule of HTT (that ensures weakening of the given strongest postcondition to an arbitrary postcondition) work together to ensure composition of verification.

We need to use the relational composition connective from HTT ($P \circ Q$) that captures how heap evolves with computation. It basically reads: $Q$ holds of the current heap which is obtained after modification of a prior heap for which P holds.

We also use HTT's difference operator ($\multimap$) below that captures changes to only the interesting fragment of the heap without modifying the rest of the heap.

We can now state the typing rules:

\paragraph{Initialization}
$x \Leftarrow \kw{mkQbit} M; E$

\begin{mathpar}
	\inferrule
	{\Delta \vdash M \chk \type{Bool}
		\\ \Delta, x : \type{Qbit}; P \circ (x \mapsto \kw{state}(M)) \vdash E \syn y:B . Q}
	{\Delta; P \vdash x \Leftarrow \kw{mkQbit} M; E \syn y:B. (\exists x:\type{Qbit}.Q)}
\end{mathpar}
where x is fresh and \texttt{state} is a function that translates a classical representation of quantum state (such as boolean here) to the equivalent quantum state vector.

Initialization can only be performed for a term $M$ that can be type checked as a \type{Bool}. Then, we look at the rest of the computation, $E$, in a context that adds $x$ of type \type{Qbit} under a precondition that extends the previous precondition, $P$, with the strongest postcondition for initialization, that is, the newly bound variable $x$ points to the representation of a new qubit state; this should synthesize the strongest postcondition (with respect to the expanded precondition in the context), $Q$, for $E$.

To avoid dangling variables, we need to existentially quantify $x$ in the postcondition, $Q$, of the conclusion.

\paragraph{Measurement}
$x \Leftarrow \kw{measQbit} M; E$

\begin{mathpar}
	\inferrule
	{\Delta \vdash M \chk \type{Qbit}
		\\ \Delta; \Psi; P \prove (M \hookrightarrow -)
		\\ \Delta, x:\type{Bool}; P \circ ((M \mapsto -) \multimap \kw{emp}) \vdash E \syn y:B . Q}
	{\Delta; P \vdash x \Leftarrow \kw{measQbit} M; E \syn y:B. (\exists x:\type{Bool}.Q)}
\end{mathpar}

The measurement rule can be read in a similar way as the previous rule. But in measurement, we need to additionally prove that the verification condition (written as a sequent), the precondition $P$ implies that the qubit $M$ is allocated, holds in the heap context $\Psi$. The strongest postcondition here is that the fragment of heap that only refers to location M becomes empty.

As may be apparent, initialization and measurement are analogous to HTT's \texttt{alloc} and \texttt{dealloc} primitives. We are working out precise details for unitary application, but at a high-level, they involve ensuring that the given unitary term actually represents a unitary matrix and updating the quantum state with the result of unitary application. This involves incorporating the monoidal structure of unitaries into our theory (as is done in QIO). This step also involves generating verification conditions that cannot be checked during this first phase of typechecking. We are also looking at alternatives such as the recently proposed sum-over-paths action semantics by \citet{amy18}.

\subsection{Sample programs}
\label{sec:examples}

In this section, we show some simple examples from the QIO work~\cite{qio} translated in our language and annotated with their program specifications using their Quantum Hoare types. An observation is that translating the programs was a very simple process except for coming up with the right specifications for the programs. We provide some commentary on assertions specified for these programs.

At the end of this section, we show a sample verification using QHTT for Bell pair generation.

\subsubsection{Hello Quantum World}
\leavevmode

\begin{minipage}{0.95\linewidth}
\begin{lstlisting}[language=QHaskell]
hqw : {emp} r : Bool {emp /\ Id(r, false)}
    = do q <= mkQbit false;
         return measQbit q
\end{lstlisting}
\end{minipage}

In this trivial program where we initialize a new qubit with \texttt{false} and then immediately measure it, we assert that the result is equal to \texttt{false}. The complete specification also implicitly says that the existing quantum state is not affected in any way as both the pre and postcondition include the \texttt{emp} assertion.

Verification steps follow:

\begin{minipage}{0.95\linewidth}
\begin{lstlisting}[language=QHaskell]
hqw : {emp} r : Bool {emp /\ Id(r, false)}
-- P0: emp
    = do q <= mkQbit false;
-- P1: P0 \o (q |-> |0\>)
         return measQbit q
-- P2: P1 \o ((q |-> -) -o emp)
\end{lstlisting}
\end{minipage}

WIP derivation tree for above program:

\begin{mathpar}
	\inferrule*[right=HIntro]
	{\inferrule*[right=consq]
		{\inferrule*[right=mkQbit]
			{\inferrule*[right=measQbit]
				{\inferrule*[right=return]
					{q : \type{Qbit}, r : \type{Bool} \vdash r \chk \type{Bool}}
					{q : \type{Qbit}, r : \type{Bool}; P_1 \circ ((q \mapsto -) \multimap emp) \vdash \kw{return} r \syn r : \type{Bool} . R}
					\\ q : \type{Qbit} \vdash q \chk \type{Qbit}
					\\ \cdot; P_0 * (q \mapsto \ket{0}) \prove (q \hookrightarrow -)
				}
				{q : \type{Qbit}; P_0 * (q \mapsto \ket{0}) \vdash r \Leftarrow \kw{measQbit} q; E_3 \syn r : \type{Bool} . (\exists r : \type{Bool}.R)}
				\\ \cdot \vdash \kw{false} \chk \type{Bool}
			}
			{
				\cdot; P_0 \vdash q \Leftarrow \kw{mkQbit false}; E_{23} \syn r : \type{Bool} . (\exists q : \type{Qbit}.R)
			}
			\\ r : \type{Bool}; i,m ; R \prove emp \multimap emp \wedge Id(r, \kw{false})
		}
		{
			\cdot; \lambda i . \lambda m . i = m \wedge (emp * \lambda m' \top)m \vdash E_1; E_{23} \chk r : \type{Bool} . (emp \multimap emp \wedge Id(r, \kw{false}))
		}
	}
	{\cdot \vdash \kw{do} E \chk \{emp\} r : \type{Bool} \{emp \wedge \kw{Id}(r, \kw{false})\}}
\end{mathpar}

\subsubsection{Coin Toss}
\leavevmode

\begin{minipage}{0.95\linewidth}
\begin{lstlisting}[language=QHaskell]
rnd : {emp} r : Bool {emp}
    = do q <= mkQbit false;
         applyU (H q);
         return measQbit q
\end{lstlisting}
\end{minipage}

In the case of quantum coin toss, the result can be in either of its two boolean values \texttt{false} or \texttt{true}, hence, we need not specify any special postcondition as type checking the result will be sufficient for correctness.

Verification steps follow:

\begin{minipage}{0.95\linewidth}
\begin{lstlisting}[language=QHaskell]
rnd : {emp} r : Bool {emp}
-- P0: emp
    = do q <= mkQbit false;
-- P1: P0 \o (q |-> |0\>)
         applyU (H q);
-- P2: P1 \o ((q |-> |0\>) -o (q |-> |+\>))
         return measQbit q
-- P3: P2 \o ((q |-> -) -o emp)
\end{lstlisting}
\end{minipage}

\subsubsection{Testing Bell Pair}
\leavevmode
\todo{TODO: Should the type be \type{Bool} $\otimes$ \type{Bool}?}

\begin{minipage}{0.95\linewidth}
\begin{lstlisting}[language=QHaskell]
testBell : {emp} (a, b) : (Bool, Bool) {emp /\ Id(a, b)}  -- a,b \in {true, false}
         = do qa <= mkQbit false;
              applyU (H qa);
              qb <= mkQbit false;
              applyU (ifQ qa (X qb));
              return (measQbit qa, measQbit qb)
\end{lstlisting}
\end{minipage}

Here, we are asserting that the returned booleans $a$ and $b$ hold the same value, which is what we expect from the first Bell state prepared in this program.

\paragraph{Verification}
We would like to describe how QHTT lets us verify the correctness of the above program based on the specification provided as the type of the function. For illustration, we show the assertions annotated as comments as we step through the \texttt{testBell} program below. We have elided specific details about unitary application as they are still being worked out.

\begin{lstlisting}[language=QHaskell]
testBell : {emp} (a, b) : (Bool, Bool) {emp /\ Id(a, b)}
              -- P0: emp
         = do qa <= mkQbit false;
              -- P1: P0 \o (qa |-> |0\>)
              applyU (H qa);
              -- P2: P1 \o ((qa |-> |0\>) -o (qa |-> |+\>))
              qb <= mkQbit false;
              -- P3: P2 \o (qb |-> |0\>)
              applyU (ifQ qa (X qb));
              -- P4: P3 \o ((qa |-> |+\>, qb |-> |0\>) -o (qa, qb) |-> |\Phi+\>)
              return (measQbit qa, measQbit qb)
              -- P5: P4 \o ((qa |-> -) -o emp) \o ((qb |-> -) -o emp)
\end{lstlisting}

In the assertion P2, we show that only the portion of the quantum state referred to by the \texttt{applyU} command is affected. Similarly, in P4 we see that only the relevant portion of the heap containing the control and target qubits used in the CNOT operation are affected. In this case, we also needed to combine the two qubit state as they are now entangled. The last assertion, P5, merely encodes the strongest postcondition for measurement for each of the two qubits.

Finally, the \texttt{consq} rule of HTT ensures that the assertion P5 leads to the specified postcondition in the type of the program.

We show some two more examples in the appendix for a modular version of Bell pair generation (\Cref{app:mbp}) that shows use of higher-order features of QHTT and another for teleportation protocol (\Cref{app:teleport}). Both of these involve specifying assertions over quantum state whose theory we still need to work out.

%\subsection{Soundness / Type Checking Algorithm}

\section{Implementation}
We are implementing QHTT in the F* programming language.

One issue with the original formulation of Hoare Type Theory is that using Hoare triples does not directly lead to a verification condition generation algorithm. This results in requiring a complicated bidirectional typing system for implementation. If we use predicate transformers as demonstrated by the use of Dijkstra monads in F*, we can avoid these issues \cite{swamy2013verifying}.

The current steps for the implementation are:

\begin{itemize}
	\item Design a memory model for representing quantum state, along with elementary operations such as read, write, lookup, etc
	\item Expose a new Quantum effect in F* by using the Dijkstra Monads for Free technique \cite{dm4free2017}.
	\item Port our language to work well with F* syntax.
\end{itemize}

This will necessarily take us away from the bidirectional typing approach used in the previous section. But the end result for the user would be the same. Indeed, F* system is an evolution of the HTT approach that comes with inherent support for effects and automation using an SMT solver.

%\section{Evaluation}

%\subsection{More Examples}
%\textit{add at least one example with scaling knob}

%\subsection{Circuit-complexity Considerations}

\section{Related Work}
\label{sec:related}
%\textit{Objective of this section\ldots}

%\subsection{Quantum Languages and Types}
%\textit{A chronology of language developments wrt to usefulness of types\ldots}

\subsection{Verification of Quantum Programs}
Previous work, such as Proto-Quipper~\cite{ross_algebraic_2015,rios_categorical_2017} and \qwire~\cite{paykin_qwire:_2017,rand_qwire_2017,rand_formally_2018} utilize a linear type system and dependent types to enforce a small subset of semantic properties, such as the no-cloning restriction and whether a unitary gate is of the right dimension. These advances in quantum type systems, although helpful, still fall short in encoding and enforcing even more useful properties that one would like to be able to express for the purpose of verification.

Our approach builds upon previous work in reasoning about quantum programs such as Quantum Weakest Preconditions~\cite{dhondt_quantum_2006} and Quantum Hoare Logic~\cite{ying_floydhoare_2012} in the spirit of \citet{hoare_axiomatic_1969} and \citet{dijkstra_discipline_1976} but attempts to bring those reasoning techniques into the type system. The hope is that programmers will be able to encode some of the semantic properties that they expect of their programs as specifications in their code and type checking will ensure correctness of some of those properties. In the classical setting, Hoare Type Theory (HTT)~\cite{nanevski_hoare_2008} accomplishes exactly this goal. Our attempt is to merge these ideas for the quantum realm.

%\textit{Add from Mingsheng Ying's book, papers, etc.}

\section{Conclusion and Perspectives}
\label{sec:conclusion}
In this paper, we have described our ongoing work on Quantum Hoare Type Theory, which modifies HTT for quantum computing using ideas from the Quantum IO monad work. This approach has the potential to be a unified system for programming, specification, and reasoning about quantum programs. We need to overcome challenges such as compactly specifying properties of quantum state when dealing with more than a few qubits. We also need to maintain the syntax directed nature of HTT's bidirectional typechecking while incorporating quantum wire types.

There are several avenues of future work to explore:

\paragraph{Quantum Language} Our programming language currently does not support conditionals or any iterative or recursive constructs. We would like to add those in future.

\paragraph{Mechanization} There are multiple implementations of HTT in Coq such as Ynot~\cite{ynot2008}. We are similarly working on mechanizing QHTT in Coq for higher assurance of the usefulness and soundness of our theory. This will also enable us to extract verified circuits in a lower level quantum language such as OpenQASM for execution on real machines.

\paragraph{Quantum Assertion Logic} An obvious need is to come up with an assertion logic similar to Separation Logic~\cite{reynolds2002} for quantum computing so as to be able to reason about only the interesting portions of the quantum state while still ensuring correctness of non-local effects such as entanglement. Various Quantum Hoare Logics that exist~\cite{ying_floydhoare_2012} currently do not support frame rules that provide Separation Logic its power.

\paragraph{Linearity} Peter Selinger and collaborators have recently proposed a linear dependent typed version of Proto-Quipper (dubbed Proto-Quipper-D)~\cite{selinger2020,fu2020linear}. It is an interesting challenge to reconcile linearity in our theory based on their proposal.

\paragraph{Circuits as Arrows} Further, Proto-Quipper treats quantum circuits as first class citizens of the language. We would like to explore modifying our theory to treat Quantum Hoare types as arrows instead of as monads as was suggested by \citet{so-arrows}. It makes sense from the perspective of sequential composition as arrows can have an arbitrary number of input/outputs as opposed to monads.

\paragraph{Behavioural Types} Another venue for exploration is to incorporate more precise types that can distinguish between qubits in pure classical state vs. those in superposition vs. those in entanglement~\cite{JorrandPerdrix2009} such as those inspired by the various quantum resource theories or the Heisenberg representation of quantum mechanics~\cite{rand_type_2019,rssl20}. This may help us provide more specific postconditions that quantum programmers expect to hold true of their programs.

\paragraph{Classical Effects} Finally, it will be an interesting challenge to reconcile both classical and quantum effects together in a single grand unified theory for effects.

%\textit{Future work about using Proto-Quipper/\qwire as languages, then extraction into QASM and checking generated verification conditions.}

\begin{acks}
	I thank John Reppy, Robert Rand and the anonymous reviewers of QPL 2020 for their feedback on an earlier presentation of this work.

	This material is based upon work supported by
	EPiQC, an \grantsponsor{GS100000001}{NSF}{http://dx.doi.org/10.13039/100000001}
	Expedition in Computing, under Grant
	No.~\grantnum{GS100000001}{1730449}.  Any opinions, findings, and
	conclusions or recommendations expressed in this material are those
	of the authors and do not necessarily reflect the views of the
	National Science Foundation.
\end{acks}

\newpage

\bibliography{references}

\newpage

\newpage

\appendix

\section{Modular Bell Pair}
\label{app:mbp}
Writing a modular version of \texttt{testBell}.

\subsection{Hadamard basis states}
\begin{lstlisting}[language=QHaskell]
qplus : {emp} r : Qbit {Id(r, |+\>)}
      = do q <= mkQbit false;
           applyU (H q);
           return q

qminus : {emp} r : Qbit {Id(r, |-\>)}
       = do q <= mkQbit true;
            applyU (H q);
            return q
\end{lstlisting}

\subsection{Creating entanglement}
\begin{lstlisting}[language=QHaskell]
share : \Pi a : Qbit.
        {a \in {|+\>, |-\>}}   -- a \in {b, c} is short for Id(a,b) \/ Id(a,c)
           b : Qbit
        {Id(a, b) /\ a \in {|0\>, |1\>}}
      = \a.do b <= mkQbit false;
              applyU (ifQ a (X b));
              return b
\end{lstlisting}

\subsection{Bell pair}
\todo{TODO: The type should be \type{Qbit} $\otimes$ \type{Qbit}}
\begin{lstlisting}[language=QHaskell]
bell : {emp} (a, b) : (Qbit, Qbit) {Id(a, b) /\ a \in {|0\>, |1\>}}
     = do qa <- qplus;
          qb <- share qa;
          return (qa, qb)
\end{lstlisting}

\subsection{Testing modular Bell pair}
\begin{lstlisting}[language=QHaskell]
testBell : {emp} (a, b) : (Bool, Bool) {emp /\ Id(a, b)}
         = do (qa, qb) <- bell;
              return (measQbit qa, measQbit qb)
\end{lstlisting}

\section{Teleportation}
\label{app:teleport}
\todo{TODO: Refine assertions}
\subsection{Alice's circuit}
\begin{lstlisting}[language=QHaskell]
alice : \Pi a : Qbit. \Pi e : Qbit
        {(Id(a, -) /\ entangled(e)}
           r : (Bool, Bool)
        {emp}
      = \a.\e.do applyU (ifQ a (X e));
                 applyU (H a);
                 return (measQbit a, measQbit e)
\end{lstlisting}

\subsection{Bob's circuit} \todo{TODO: With \texttt{if ... then ... else} removed, this will not work}
\begin{lstlisting}[language=QHaskell]
bob : \Pi m1 m2 : Bool. \Pi e : Qbit
      {entangled(e)}
         r : Qbit
      {(Id(r, -)}
      = \m1.\m2.\e.do if m1 then applyU (Z e) else ();
                      if m2 then applyU (X e) else ();
                      return e
\end{lstlisting}

\subsection{Teleport}
\begin{lstlisting}[language=QHaskell]
teleport : \Pi q : Qbit. x : Pure.
           {Id(q, x)}
              r : Qbit
           {Id(r, x)}
         = \q.do (a, b) <- bell;
                 (m1, m2) <- alice q a;
                 tq <- bob m1 m2 b;
                 return tq
\end{lstlisting}

%\section{Sample Proof}
%\textit{Coq code / Annotated proof objects from implementation\ldots}

\end{document}
